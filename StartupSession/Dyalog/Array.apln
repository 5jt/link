:Namespace Array   ⍝ A model for a literal notation for most APL arrays
    ⎕ML←1
    DEBUG←1

    :Namespace serialise
        :Section UTIL
        (sp qu os cs or cr oc cc ec di nl)←' ''[](){}⊂⋄',⎕UCS 13
          Clean←{
              t←'^'''',' ',''''$'⎕R''⊢⍵
              one←2=+/'()'∊⍨'''[^'']+'''⎕R''⊢t
              strip←one∧'()'≡(⊃,⊢/)t
              (strip↓⌽)⍣2⊢t
          }
          Esc←{
              Sub←{
                  cont←⍵.Lengths[3]
                  nums←⍕⎕UCS ⍵.Match↓⍨-cont
                  ''',',(cont⍴'('),'⎕UCS ',nums,cont/'),''',⊃⌽⍵.Match
              }
              '([\x00-\x1F\x80-\xA0\x{2028}\x{2029}\x{FEFF}]+)(.?)'⎕R Sub⍠'Mode' 'D'⊢⍵
          }
        Unempty←⊢↑⍨1⌈≢
          Empty←{
              ⍵,⍨'0⌿'/⍨Lead0 ⍺
          }
          _Sub_←{
              (o c)←⍵⍵
              inner←∊⍺⍺ Unempty ⍵
              ⍵ Empty o,nl,inner,c
          }
        Join←{⍺←nl ⋄ ¯1↓∊⍵,¨⍺}
          _Paren_←{
              res←⍵⍵ ⍵
              ⍺⍺ res:or,res,cr
              res
          }
        :EndSection
        :Section REPR
          Repr←{
              ⍬≡⍵:'⍬'
              Char ⍵:Clean Esc qu,(qu ⎕R qu qu⊢⍵),qu
              Num ⍵:⍕⍵⊣(⎕FR ⎕PP)←1287 34
              ⎕NULL∧.=⍵:'⎕NULL'⍴⍨5×≢⍵
              ~Scal ⍵:⎕SIGNAL 999
              Ns ⍵
          }
        ∇ repr←Ns ref;name;names;code;ser;ind
          :Trap 0
              repr←or,(Join ⎕SRC ref),cr
          :Else
              repr←or nl
         
              names←'⎕'(=⊂⊢)'⎕CT⎕DIV⎕IO⎕ML⎕PP⎕RL⎕RTL⎕WX⎕USING⎕AVU⎕DCT⎕FR'
              names/⍨←≢⌿ref ref.##∘.⍎names
              names,←ref.⎕NL-⍳9
         
              :For name :In names
                  code←Join ref.⎕NR name
         
                  :Select ref.⎕NC⊂name
                  :CaseList 3.1 4.1
                      repr,←name,':(∇',code,nl,'∇)'
                  :CaseList 3.2 4.2
                      repr,←1↓':'@(<\'←'=⊢)code
                  :CaseList 3.3 4.3
                      repr,←name,':',1↓¯1↓(183 ref.⌶Tacit ref.⎕NR)name
                  :Else
                      repr,←name,':',Ser ref⍎name
                  :EndSelect
                  repr,←nl
              :EndFor
         
              repr,←cr
          :EndTrap
        ∇
          Tacit←{
              2 9∊⍨⊂⍺:Ser ⍵        ⍝ array
              0≠≡⍺:∊or,(⍺ ∇¨⍵),cr  ⍝ derv
              ⍬≡⍴⍵:⍵               ⍝ primitive
              code←Join ⍵
              '}'=⊃⌽⊃⌽⍵:code       ⍝ dfn
              '(∇',code,nl,'∇)'    ⍝ tradfn
          }
        :EndSection
        :Section TYPE
        Char←0 2∊⍨10|⎕DR
        Num←~0 2 6∊⍨10|⎕DR
        Null←⎕NULL∧.=⊢
        Ptr←6=10|⎕DR
        Basic←Char∨Num∨Null
        :EndSection
        :Section PROP
        Simple←{1=≡,⍵}
        Scal←⍬≡⍴
        Nested←{1<|≡⍵}
        Vec1←{(,1)≡⍴⍵}
        HiRank←{1<≢⍴⍵}
        Vec←{1=≢⍴⍵}
        Mat←{2=≢⍴⍵}
        String←Simple∧Char∧Vec
        Table←Mat>0∊(String∨Simple∧Scal∧Num∨Null)¨
        Lead0←0∊⍴
        :EndSection
          Ser←{
              (Simple∧Scal)⍵:Repr ⍵
              Scal ⍵:ec,∇⊃⍵
         
              Self←⊂nl,⍨∇
         
              Table ⍵:Join os,cs,⍨{(+/∨\' '≠⌽⍵)↑¨↓⍵}0 1↓⊃,/' ',¨↑¨↓⍉(∨/'⎕UCS'⍷'''[^'']+'''⎕R'')_Paren_ Ser¨⍵
              HiRank ⍵:Self⍤¯1 _Sub_ os cs⊢⍵
              Nested ⍵:Self¨_Sub_ or cr⊢⍵
         
              Vec1 ⍵:or,(∇⊃⍵),di cr
         
              (Basic∨Scal)⍵:Repr ⍵
              ∧/Basic¨⍵:sp Join(6≤≢)_Paren_ Repr¨⍵
         
              Self¨_Sub_ or cr⊢⍵ ⍝ hetero
          }
    :EndNamespace
      Serialise←{
          ⍺←0
          code←serialise.Ser ⍵
          split←{(+/∨\' '≠⌽⍵)↑¨↓⍵}⎕FMT code
     
          1=⍺:'''[^'']+''' '([[(]) ⋄ ' ' ⋄ ([])])' '  +'⎕R'&' '\1' ' ⋄\1' ' '⊢3↓∊' ⋄ '∘,¨split
     
          spaces←⌊|⍺+2×0=⍺
          fmt←⎕FMT'''[^'']+''' '\[[^][]+\]' '\([^)(]+\)'⎕R''⍣≡code
          delta←¯1⌽+/fmt∊'(['
          delta-←+/fmt∊')]'
          ind←spaces×+\delta
          ind{⍵,⍨⍺⍴''}¨split
      }

      Deserialise←{ ⍝ Convert text to array
          ⍺←1 ⍝ 1=execute expression; 0=return expression
          q←''''
          ⎕IO←0
          SEP←'⋄',⎕UCS 10 13
     
          Unquot←{(⍺⍺ ⍵)×~≠\q=⍵}
          SepMask←∊∘SEP Unquot
          ParenLev←+\(×¯3+7|¯3+'([{)]}'∘⍳)Unquot
     
          Paren←1⌽')(',⊢
          Split←{1↓¨⍺⍺⊂Over(1∘,)⍵}
     
          Over←{(⍵⍵ ⍺)⍺⍺(⍵⍵ ⍵)}
          EachIfAny←{0=≢⍵:⍵ ⋄ ⍺ ⍺⍺¨⍵}
          EachNonempty←{⍺ ⍺⍺ EachIfAny Over((×≢¨⍵~¨' ')/⊢)⍵}
     
          Parse←{
              0=≢⍵:''
              bot←0=⍺
              (2≤≢⍵)>∨/¯1↓bot:⍺ SubParse ⍵
              p←bot×SepMask ⍵
              ∨/p:∊{1=≢⍵:',⊂',⍵ ⋄ ⍵}⍺(Paren ∇)EachNonempty Over(p Split)⍵
              p←2(1,>/∨¯1↓0,</)bot
              ∨/1↓p:∊(p⊂⍺)∇¨p⊂⍵
              ⍵
          }
     
          ErrIfEmpty←{⍵⊣'Empty array'⎕SIGNAL 11/⍨0=≢⍵}
     
          SubParse←{
              ('})]'⍳⊃⌽⍵)≠('{(['⍳⊃⍵):'Bad bracketing'⎕SIGNAL 2
              (a w)←(1↓¯1∘↓)¨(⍺-1)⍵
              '['=⊃⍵:Paren'{⎕ML←1⋄↑⍵}1/¨',Paren ErrIfEmpty a Parse w ⍝ high-rank
              ':'∊⍵/⍨(1=⍺)×~≠\q=⍵:a Namespace w ⍝ ns
              '('=⊃⍵:Paren{⍵,'⎕NS⍬'/⍨0=≢⍵}a Parse w ⍝ vector/empty ns
              ⍵ ⍝ dfn
          }
     
          ParseLine←{
              c←⍵⍳':'
              1≥≢(c↓⍵)~' ':'Missing value'⎕SIGNAL 6
              name←c↑⍵
              ¯1=⎕NC name:'Invalid name'⎕SIGNAL 2
              name(name,'←',⍺ Parse Over((c+1)↓⊢)⍵)
          }
     
          Namespace←{
              p←(0=⍺)×SepMask ⍵
              (names assns)←↓⍉↑⍺ ParseLine EachNonempty Over(p Split)⍵
              ∊'({'(assns,¨'⋄')'⎕NS'('(, '∘,¨q,¨names,¨⊂q')')'}⍬)'
          }
     
          Execute←{   ⍝ overcome LIMIT ERROR on more than 4096 parenthesised expressions
              ExecuteEach←{         ⍝ split at level-1 parentheses and execute each
                  l←(t=¯1)++\t←1 ¯1 0['()'⍳⍵]           ⍝ parenthesis type and level
                  (h x t l)←(1 0 0 0=⊂∧\l=0)/¨⍵ ⍵ t l   ⍝ extract header before first opening parenthesis
                  ⍺{0::0 ⋄ r←⍺⍎⍵ ⋄ ~(⊃⎕NC'r')∊3 4}h:⍺⍎⍵ ⍝ header must be an functional expression
                  H←⍺{⍺⍺⍎⍵⍵,'⍵'}h                       ⍝ function to apply header to array
                  ' '∨.≠(l=0)/x:⍺⍎⍵                     ⍝ something outside level-1 parentheses - must fall back to ⍎
                  x←(((l>0)∧(l≠1)∨(t=0))×+\(t=1)∧(l=1))⊆x   ⍝ cut expression within level-1 parentheses
                  1=≢x:H ⍺ ∇⊃x                          ⍝ single expression : don't enclose with ¨
                  DEBUG∧1<⌈/l:H ⍺ ∇¨x                    ⍝ force going through the hard code
                  10::H ⍺ ∇¨x ⋄ H ⍺⍎¨x                  ⍝ attempt to ⍎¨ with a single guard - otherwise dig each
              }
              DEBUG:⍺ ExecuteEach ⍵           ⍝ force going through the hard code
              10::⍺ ExecuteEach ⍵ ⋄ ⍺⍎⍵       ⍝ attempt simple ⍎ and catch LIMIT ERROR
          }
     
          w←↓⍣(2=≢⍴⍵)⊢⍵                  ⍝ mat?
          w←{¯1↓∊⍵,¨⎕UCS 13}⍣(2=|≡w)⊢w   ⍝ vtv?
          w←'''[^'']*''' '⍝.*'⎕R'&' ''⊢w ⍝ strip comments
     
          pl←ParenLev w
          (0≠⊢/pl)∨(∨/0>pl):'Unmatched brackets'⎕SIGNAL 2
          ∨/(pl=0)×SepMask w:'Multi-line input'⎕SIGNAL 11
          (⊃⎕RSI)Execute⍣⍺⊢pl Parse w    ⍝ materialise namespace as child of calling namespace
      }


      Inline←{
          aa←⍺⍺
          (1≡⊃⍵,1)Deserialise 1↓∊(⎕UCS 13),¨'^( *[\w∆⍙]+ *← *)?{( |\R)*|( |\R)*}\R*$'⎕R''⍠'Mode' 'D'⎕NR'aa'
      }


      Is←{
          0::'MISMATCH'⎕SIGNAL 999
          a←Serialise ⍺⍺ Inline 1
          a≡Serialise ⍵:
          a≡Serialise ⎕JSON ⍵:
          ∧/⍵(1∊⍷)¨⊂↑a:
          !#
      }


      Ed←{ ⍝ Skip ⍺⍺ QA if interpreter skips lines that look like invalid ∇ Editor directives
          </⍋(18 1)(⊃⌽'.'⎕VFI 1⊃# ⎕WG'APLVersion'):⍺⍺ ⍵
      }


      ∆NS←{ ⍝ allows ⎕NS names values
          ⍺←⊢ ⍝ default to unnamed namespace
          11::⎕SIGNAL 11
          (0=≢⍵)∨2≥|≡⍵:{_←⍵}⍣(2∊⎕NC'⍺')⊢⍺ ⎕NS ⍵ ⍝ default behaviour
          {_←⍵}⍣(2∊⎕NC'⍺')⊃⊃(⍺⊣⍣(2∊⎕NC'⍺')⊢⍺ ⎕NS ⍬){ ⍝ new behaviour
              (,1)≢(⍴,≡)⍵:⍺⍺⍎⍺,'←⍵ ⋄ ⍺⍺' ⍝ non-⎕OR: use value
              4 11::⍺⍺⍎⍺,'←⎕NS ⍵ ⋄ ⍺⍺' ⍝ object?
              ⍺⍺⍎⍺,'←⍎⎕FX ⍵ ⋄ ⍺⍺⊣⍺{⍺≡⍵:⍬ ⋄ ⎕EX ⍵}⎕FX ⍵' ⍝ function?
          }¨/⍵
      }

      ∆NSinverse←{ ⍝ ⎕NS⍣¯1
          ⍵∘⍎¨'⎕NL-⍳9' '⎕OR¨⎕NL-⍳9' ⍝ names values
      }










    ∇ r←SerialiseQA stop_on_error;⎕IO;Is;⎕TRAP
      ⎕IO←0
      ⎕TRAP←(~stop_on_error)/⊂999 'C' '→r←0'
      Is←{
          0::'MISMATCH'⎕SIGNAL 999
          a←Serialise ⍺⍺ Inline 1
          a≡Serialise ⍵:
          a≡Serialise ⎕JSON ⍵:
          ∧/⍵(1∊⍷)¨⊂↑a:
          !#
      }
     
      :Section scalars
          {
              ⎕NULL
          }Is ⎕NULL
          {
              'a'
          }Is'a'
          {
              ''''
          }Is''''
          {
              (⎕UCS 0)
          }Is ⎕UCS 0
          {
              (⎕UCS 13)
          }Is ⎕UCS 13
          {
              (⎕UCS 10)
          }Is ⎕UCS 10
          {
              42
          }Is 42
      :EndSection
      :Section vectors
          {(42 ⋄ )}Is,42
     
          {(42
              )}Is,42
     
          {
              (1 2 3 'Hello' ⋄ 4 5 6 'World')
          }Is(1 2 3 'Hello')(4 5 6 'World')
     
          {
              (1 2 3 'Hello'
              4 5 6 'World')
          }Is(1 2 3 'Hello')(4 5 6 'World')
     
          {
              (0 1 ⋄ 2 3
              4 5 ⋄ 6 7)
          }Is↓4 2⍴⍳8
     
          {
              ('Three'
              'Blind'
              'Mice')
          }Is'Three' 'Blind' 'Mice'
      :EndSection
      :Section Matrices
          {[0 1 2
              3 4 5]
          }Is 2 3⍴⍳6
     
          {[ ⋄ 0 1 2 3]
          }Is⍉⍪⍳4
     
          {[
              0 1 2 3
              ]
          }Is⍉⍪⍳4
     
          {['Three'
              'Blind'
              'Mice']
          }Is 3 5⍴'ThreeBlindMice '
     
          {[
              ('Three'
              'Blind'
              'Mice')
              ]
          }Is 1 3⍴'Three' 'Blind' 'Mice'
     
          {[1 ⋄ ]
          }Is⍪1
     
          {
              1 2[1 ⋄ ]
          }Is 1 2(⍪1)
      :EndSection
      :Section Combo
          {
              ([0 0 1
              1 0 1
              0 1 1]
     
              [0 1 1
              1 1 0
              0 1 0]
     
              [0 1 1 1
              1 1 1 0]
     
              [0 1 1 0
              1 0 0 1
              0 1 1 0])
     
          }Is Ed{
              _←⍉⍪0 0 1
              _⍪←1 0 1
              _⍪←0 1 1
              r←⊂_
              _←⍉⍪0 1 1
              _⍪←1 1 0
              _⍪←0 1 0
              r,←⊂_
              _←⍉⍪0 1 1 1
              _⍪←1 1 1 0
              r,←⊂_
              _←⍉⍪0 1 1 0
              _⍪←1 0 0 1
              _⍪←0 1 1 0
              r,←⊂_
              r
          }⍬
     
          {[0 'OK' ⋄ 1 'WS FULL' ⋄ 2 'SYNTAX ERROR' ⋄ 3 'INDEX ERROR' ⋄ 4 'RANK ERROR']
          }Is{
              e←⍉⍪0 'OK'
              e⍪←1 'WS FULL'
              e⍪←2 'SYNTAX ERROR'
              e⍪←3 'INDEX ERROR'
              e⍪←4 'RANK ERROR'
              e
          }⍬
          {['a'(⊂1 2)'a'
              (⊂1 2)'a'(⊂1 2)]
          }Is 2 3⍴'a'(⊂1 2)
      :EndSection
     
      :Section High Rank
          {
              [[3
              1 5 9]
              [2 7 1
              2 8]]
          }Is Ed 2 2 3⍴3 0 0 1 5 9 2 7 1 2 8 0
          {
              [
              [
              [
              1 2 3
              4 5 6
              ]
              ]
              ]
          }Is Ed 1 1 2 3⍴1 2 3 4 5 6
          {
              [
              [
              [
              1
              ]
              [
              2
              ]
              ]
              [
              [
              3
              ]
              [
              4
              ]
              ]
              [
              [
              5
              ]
              [
              6
              ]
              ]
              ]
          }Is Ed 3 2 1 1⍴1 2 3 4 5 6
     
      :EndSection
     
      :Section Empty
          {
              ⍬
          }Is ⍬
          {
              (⍬ ⋄ )
          }Is,⊂⍬
          {
              0⍴⊂⍬
          }Is 0⍴⊂⍬
          {
              0⍴⊂⊂⍬
          }Is 0⍴⊂⊂⍬
          {
              0⍴⊂0⍴⊂⍬
          }Is 0⍴⊂0⍴⊂⍬
          {[⍬ ⋄ ]
          }Is⍉⍪⍬
          {
              ⍉[⍬ ⋄ ]
          }Is⍪⍬
          {
              0⍴⊂[⍬ ⋄ ]
          }Is 0⍴⊂⍉⍪⍬
          {
              0⍴⊂⍉[⍬ ⋄ ]
          }Is 0⍴⊂⍪⍬
      :EndSection
     
      :Section Namespace
          {
              ()
          }Is'{}'
     
          {
              (
              )
          }Is'{}'
     
          {
              ()()
          }Is'[{},{}]'
     
          {
              (a:⍳n←3 ⋄ b:n*2)
          }Is'{"a":[0,1,2],"b":9}'
     
          {
              (p:{⍺+⍵}
              m:{⍺-⍵}
              s:,∘(,',')((,',')∘,)
              o:⍣2)
          }Is'p:{⍺+⍵}' 'm:{⍺-⍵}' 's:(,∘(' '))((' ')∘,)' 'o:⍣2'
     
          {
              (v:(1 2 ⋄ 3))
          }Is'{"v":[[1,2],3]}'
     
          {
              (v:(1 2
              3))
          }Is'{"v":[[1,2],3]}'
     
          {
              (v:(1 2 ⋄ 3)
              )
          }Is'{"v":[[1,2],3]}'
     
          {
              (
              ()
              )
          }Is'[{}]'
     
          {(n:())}Is'{"n":{}}'
     
      :EndSection
      r←1
    ∇


    ∇ r←DeserialiseQA stop_on_error;⎕IO;Is;⎕TRAP
      ⎕IO←0
      ⎕TRAP←(~stop_on_error)/⊂999 'C' '→r←0'
      Is←{
          Check←'MISMATCH'⎕SIGNAL 999/⍨⍵∘≢
          a←⍺⍺ Inline 1
          ×⎕NC'⍺':Check a.⎕NR ⍺
          Check{⎕JSON⍣(326∊⎕DR¨∊⍵)⊢⍵}⍣(⍵≢⎕NULL)⊢a
      }
     
      :Section scalars
          {
              'a'
          }Is'a'
          {
              42
          }Is 42
          {
              ⎕NULL
          }Is ⎕NULL
          {
              ⎕UCS 0
          }Is ⎕UCS 0
      :EndSection
      :Section vectors
          {(42 ⋄ )}Is,42
     
          {(42
              )}Is,42
     
          {'Hello',⎕AV}Is'Hello',⎕AV
     
          {
              (1 2 3 'Hello' ⋄ 4 5 6 'World')
          }Is(1 2 3 'Hello')(4 5 6 'World')
     
          {
              (1 2 3 'Hello'
              4 5 6 'World')
          }Is(1 2 3 'Hello')(4 5 6 'World')
     
          {
              (0 1 ⋄ 2 3
              4 5 ⋄ 6 7)
          }Is↓4 2⍴⍳8
     
          {
              ('Three'
              'Blind'
              'Mice')
          }Is'Three' 'Blind' 'Mice'
      :EndSection
      :Section Matrices
          {[0 1 2
              3 4 5]
          }Is 2 3⍴⍳6
     
          {[ ⋄ 0 1 2 3]
          }Is⍉⍪⍳4
     
          {[
              0 1 2 3
              ]
          }Is⍉⍪⍳4
     
          {['Three'
              'Blind'
              'Mice']
          }Is 3 5⍴'ThreeBlindMice '
     
          {[1 ⋄ ]
          }Is⍪1
     
          {
              1 2[1 ⋄ ]
          }Is 1 2(⍪1)
      :EndSection
      :Section Combo
          {
              ([0 0 1
              1 0 1
              0 1 1]
     
              [0 1 1
              1 1 0
              0 1 0]
     
              [0 1 1 1
              1 1 1 0]
     
              [0 1 1 0
              1 0 0 1
              0 1 1 0])
     
          }Is Ed{
              _←⍉⍪0 0 1
              _⍪←1 0 1
              _⍪←0 1 1
              r←⊂_
              _←⍉⍪0 1 1
              _⍪←1 1 0
              _⍪←0 1 0
              r,←⊂_
              _←⍉⍪0 1 1 1
              _⍪←1 1 1 0
              r,←⊂_
              _←⍉⍪0 1 1 0
              _⍪←1 0 0 1
              _⍪←0 1 1 0
              r,←⊂_
              r
          }⍬
     
          {[0 'OK' ⋄ 1 'WS FULL' ⋄ 2 'SYNTAX ERROR' ⋄ 3 'INDEX ERROR' ⋄ 4 'RANK ERROR']
          }Is{
              e←⍉⍪0 'OK'
              e⍪←1 'WS FULL'
              e⍪←2 'SYNTAX ERROR'
              e⍪←3 'INDEX ERROR'
              e⍪←4 'RANK ERROR'
              e
          }⍬
          {['a'(⊂1 2)'a'
              (⊂1 2)'a'(⊂1 2)]
          }Is 2 3⍴'a'(⊂1 2)
      :EndSection
     
      :Section High Rank
          {
              [[3
              1 5 9]
              [2 7 1
              2 8]]
          }Is Ed 2 2 3⍴3 0 0 1 5 9 2 7 1 2 8 0
      :EndSection
     
      :Section Empty
          {
              ⍬
          }Is ⍬
          {
              (⍬ ⋄ )
          }Is,⊂⍬
          {
              0⍴⊂⍬
          }Is 0⍴⊂⍬
          {
              0⍴⊂⊂⍬
          }Is 0⍴⊂⊂⍬
          {
              0⍴⊂0⍴⊂⍬
          }Is 0⍴⊂0⍴⊂⍬
          {[⍬ ⋄ ]
          }Is⍉⍪⍬
          {
              ⍉[⍬ ⋄ ]
          }Is⍪⍬
          {
              0⍴⊂[⍬ ⋄ ]
          }Is 0⍴⊂⍉⍪⍬
          {
              0⍴⊂⍉[⍬ ⋄ ]
          }Is 0⍴⊂⍪⍬
      :EndSection
     
      :Section Namespace
          {
              ()
          }Is'{}'
     
          {
              (
              )
          }Is'{}'
     
          {
              ()()
          }Is'[{},{}]'
     
          {
              (a:⍳n←3 ⋄ b:n*2)
          }Is'{"a":[0,1,2],"b":9}'
     
          'p' 'm'{
              (p:+
              m:{⍺-⍵})
          }Is¨(,'+')(,⊂' m←{⍺-⍵}')
     
          {
              (v:(1 2 ⋄ 3))
          }Is'{"v":[[1,2],3]}'
     
          {
              (v:(1 2
              3))
          }Is'{"v":[[1,2],3]}'
     
          {
              (v:(1 2 ⋄ 3)
              )
          }Is'{"v":[[1,2],3]}'
     
          {
              (
              ()
              )
          }Is'[{}]'
     
          {(n:())}Is'{"n":{}}'
     
      :EndSection
      r←1
    ∇




    ∇ r←RoundtripQA stop_on_error;⎕IO;Is;⎕TRAP
      ⎕IO←0
      ⎕TRAP←(~stop_on_error)/⊂999 'C' '→r←0'
      Is←{
          Check←'MISMATCH'⎕SIGNAL 999/⍨≢
          ⍝ identical nss don't match, so we compare the generated notation:
          9∊{⊃⎕NC'⍵'}¨∊⍵:(Serialise ⍵)Check Serialise Deserialise Serialise ⍵
          ⍵ Check Deserialise Serialise ⍵
      }
     
      :Section scalars
          Is'a'
          Is 42
          Is ⎕NULL
          Is ⎕UCS 0
          Is ⎕UCS 13
      :EndSection
      :Section vectors
          Is,42
          Is,42
          Is'Hello',⎕AV
          Is(1 2 3 'Hello')(4 5 6 'World')
          Is(1 2 3 'Hello')(4 5 6 'World')
          Is↓4 2⍴⍳8
          Is'Three' 'Blind' 'Mice'
      :EndSection
      :Section Matrices
          Is 2 3⍴⍳6
          Is⍉⍪⍳4
          Is⍉⍪⍳4
          Is 3 5⍴'ThreeBlindMice '
          Is⍪1
          Is 1 2(⍪1)
      :EndSection
      :Section Combo
          Is{
              _←⍉⍪0 0 1
              _⍪←1 0 1
              _⍪←0 1 1
              r←⊂_
              _←⍉⍪0 1 1
              _⍪←1 1 0
              _⍪←0 1 0
              r,←⊂_
              _←⍉⍪0 1 1 1
              _⍪←1 1 1 0
              r,←⊂_
              _←⍉⍪0 1 1 0
              _⍪←1 0 0 1
              _⍪←0 1 1 0
              r,←⊂_
              r
          }⍬
     
          Is{
              e←⍉⍪0 'OK'
              e⍪←1 'WS FULL'
              e⍪←2 'SYNTAX ERROR'
              e⍪←3 'INDEX ERROR'
              e⍪←4 'RANK ERROR'
              e
          }⍬
          Is 2 3⍴'a'(⊂1 2)
          Is 3 3⍴(,¨'1' '0' '1')
          Is'Hello'('' '⍝World:')
          Is'AB''C',⊂'DE'
          Is'ABC'(,⊂⊂'')
          Is'A'(,⊂⊂'')
      :EndSection
     
      :Section High Rank
          Is 1 1 2 3⍴⍳6     ⍝ issue #254
          Is 3 2 1 1⍴⍳6     ⍝ issue #254
          Is 2 3 4 5⍴⍳120   ⍝ issue #254
          Is⊂[3 4 5]⎕A[?1 2 3 1 5 6⍴26]      ⍝ issue #254
      :EndSection
     
      :Section Large Arrays                  ⍝ (more than 4096 constants) - issue #255
          Is⊂[2 3]?50 100 2 3⍴100            ⍝ Numeric is straightforward
          Is⊂[3 4 5]⎕A[?50 10 10 1 2 3⍴26]   ⍝ Text gets functional headers produced by Parse
      :EndSection
     
      :Section Empty
          Is ⍬
          Is,⊂⍬
          Is 0⍴⊂⍬
          Is 0⍴⊂⊂⍬
          Is 0⍴⊂0⍴⊂⍬
          Is⍉⍪⍬
          Is⍪⍬
          Is 0⍴⊂⍉⍪⍬
          Is 0⍴⊂⍪⍬
      :EndSection
     
      :Section Namespace
          Is ⎕JSON'{}'
          Is ⎕JSON'{}'
          Is ⎕JSON'[{},{}]'
          Is ⎕JSON'{"a":[0,1,2],"b":9}'
          Is{
              ⍺←⎕NS ⍬
              ⍺.p←{⍺+⍵}
              ⍺.m←{⍺-⍵}
              ⍺
          }⍬
          Is ⎕JSON'{"v":[[1,2],3]}'
          Is ⎕JSON'{"v":[[1,2],3]}'
          Is ⎕JSON'{"v":[[1,2],3]}'
          Is ⎕JSON'[{}]'
          Is ⎕JSON'{"n":{}}'
      :EndSection
      r←1
    ∇


    ∇ r←QA
    ⍝ fails under 18.0 because of mantis 18132
      r←SerialiseQA 1
      r∧←DeserialiseQA 1
      r∧←RoundtripQA 1
    ∇

:EndNamespace
