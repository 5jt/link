 (inFail fsw)←opts FixFiles target;Files;RightExtn;TryFixThere;actnames;actnc;allfiles;allnames;dirs;expfiles;expnames;exts;files;hidden;hideBit;inx;list;mask;names;ndirs;nss;parents;source;⎕IO
 ⍝ Load items from files in folders
 :If U.debug=2
     (1+⊃⎕LC)⎕STOP⊃⎕SI
 :EndIf
 :Trap DEBUG↓0
     ⎕IO←1

     ⍝ TODO : beforeRead

     source←opts.dir ⋄ inFail←⍬
     list←0 1 6 ⎕NINFO⍠1⍠'Recurse' 1⊢source,'/*'     ⍝ recursive listing of everything

     hideBit←1=3⊃list                                ⍝ mask for hidden items
     hidden←⊃list U.Where¨⊂hideBit                   ⍝ list of hidden (files and) folders
     hidden,¨←'/'                                    ⍝ protect agains similarly named items
     list←list U.Where¨⊂~hideBit                     ⍝ keep only visible items
     list←list U.Where¨⊂~∨⌿hidden∘.U.Begins⊃list     ⍝ filter away things that come below hidden things
     list↓⍨←¯1                                       ⍝ remove hideBit column

     dirs←(⊃U.Where/1=@2⊢list)                       ⍝ second column has 1 for dirs
     dirs←((⊂opts.dir),{⍵[⍋⍵]}dirs),¨'/'             ⍝

     RightExtn←{⍺∊⍨⊂1↓⊃⌽⎕NPARTS ⍵}                   ⍝ Ends with specified extension?
     Files←{⍵ U.Where ⍺∘RightExtn¨⍵}                 ⍝ Those that end with specified extension
     exts←opts.(codeExtensions,customExtensions,⊢/typeExtensions) ⍝ all the interesting extensions
     files←exts Files⊃U.Where/2=@2⊢list              ⍝ second column has 2 for files; first column is filename
     files←files[U.GradeFiles files]

     ndirs←≢dirs ⋄ allfiles←dirs,files
     (parents expnames actnames actnc)←↓⍉↑opts U.DetermineAplName¨allfiles  ⍝ expected names (one per file), actual names (one list per file), actual name classes (one list per file)
     mask←1≠≢¨actnames   ⍝ defines 0 name (invalid source) or more than 1 name (not supported by link)
     mask∨←actnc∊⊂,¯1    ⍝ invalid names
     inFail,←mask/allfiles
     (allfiles parents expnames actnames actnc)/⍨←⊂~mask    ⍝ keep only names that are valid
     ndirs←+/ndirs↑~mask
     actnames←⊃¨actnames ⋄ actnc←⊃¨actnc  ⍝ we know there is only one name per file

     ⍝ detect clashing names
     allnames←parents('.'U.Join¨)actnames  ⍝ fully qualified names
     :If ∨/mask←(inx←⍳⍨allnames)≠(⍳≢allnames)
         files←allfiles[,(mask/inx),[1.5]⍸mask]
         U.Error'Files produce clashing APL names:',⍕files
     :EndIf

     ⍝ rename files if incorrectly named
     :If opts.forceFilenames∨opts.forceExtensions
         expfiles←⊃¨U.DetermineFileName¨↓⍉↑((≢allfiles)/opts)parents actnames actnames actnc
         :If ∨/mask←expfiles≢¨allfiles
             :If (≢expfiles)≠(≢∪819⌶expfiles)
                 U.Error'Forcing file names would produce clashing file names: use forceFilenames=0 or caseCode=1'
             :Else
                 ⍝ because APL names don't clash, we now expfiles won't clash either
                 ⍝ however expfiles may overlap allfiles, producing an error at intermediate steps (⎕NMOVE should fail, because ⍠'IfExists' 'Error')
                 (mask/expfiles)U.Relocate(mask/allfiles)
                 allfiles←expfiles
             :EndIf
         :EndIf
     :EndIf

     ⍝ create namespaces for directories and load quadVars.apln
     (dirs names)←ndirs↑¨(allfiles allnames)
     :If ~opts.flatten                               ⍝ If we are not flattening, create nss
         nss←U.GetRefTo U.OnEach names
     :Else
         nss←target   ⍝ all files fixed in target namespace
     :EndIf
     {}nss{⎕NEXISTS ⍵:⍺ QFix ⍵ opts ⋄ ⍬}U.OnEach dirs,¨⊂'quadVars.apln' ⍝ set sysvars - these files are produced by Acre and must be supported

     ⍝ fix individual files
     (files names)←ndirs∘↓¨(allfiles allnames)
     TryFixThere←{      ⍝ Try to fix file ⍵ in namespace ⍺
         6 11::⍵        ⍝ return name on failure
         0⊣⍺ QFix ⍵ opts ⍝ do it and return 0 on success
     }
     :If ~opts.flatten                               ⍝ If we are not flattening, create nss
         nss←⍎∘U.Parent U.OnEach names
     :Else
         nss←target   ⍝ all files fixed in target namespace
     :EndIf
     inFail,←0~⍨nss TryFixThere U.OnEach files ⍝ try it and return only failures

     ⍝ return (list of failures) and (watcher reference or zilde)
     :If 'dir' 'both'∊⍨⊂opts.watch
         fsw←FileSystemWatcher.Watch(source)(,'*')
     :Else
         fsw←⍬
     :EndIf
     inFail←⍕¨inFail
 :Else
     U.Resignal 1
 :EndTrap
