 {inFail}←opts FixFiles(target source);TryFixThere;actnames;actnc;allfiles;allnames;dirs;expfiles;expnames;exts;files;hidden;inx;list;mask;names;ndirs;nss;parents;source;⎕IO
 ⍝ Load items from files in folders
 :If U.debug=2
     (1+⊃⎕LC)⎕STOP⊃⎕SI
 :EndIf
 :Trap DEBUG↓0
     ⎕IO←1

     ⍝ TODO : beforeRead

     inFail←⍬
     list←↑0 1 6 ⎕NINFO⍠1⍠'Recurse' 1⊢source,'/*'    ⍝ recursive listing of everything  list[filename type hidden;]

     mask←1=list[3;] ⋄ list←¯1↓list                  ⍝ mask for hidden items
     hidden←mask/list ⋄ list/⍨←~mask                 ⍝ crop hidden (files and) folders
     hidden←(1=hidden[2;])/hidden[1;]                ⍝ keep directories only (files have already been removed from list)
     hidden←hidden,¨'/'                              ⍝ protect against similarly named files
     list/⍨←~∨⌿hidden∘.U.Begins list[1;]             ⍝ filter away things that come below hidden directories

     dirs←(1=list[2;])/list[1;]                      ⍝ second column has 1 for dirs
     dirs←((⊂opts.dir),{⍵[⍋⍵]}dirs),¨'/'             ⍝ all directories (including link root)

     files←(2=list[2;])/list[1;]                     ⍝ second column has 2 for files; first column is filename
     files/⍨←opts U.HasExtn files                    ⍝ must be of correct extension
     files←files[U.GradeFiles files]                 ⍝ dirs then quads then files

     ndirs←≢dirs ⋄ allfiles←dirs,files
     (parents expnames actnames actnc)←↓⍉↑opts U.DetermineAplName¨allfiles  ⍝ expected names (one per file), actual names (one list per file), actual name classes (one list per file)
     mask←actnc∊¯1 0    ⍝ invalid names or source
     inFail,←mask/allfiles
     (allfiles parents expnames actnames actnc)/⍨←⊂~mask    ⍝ keep only names that are valid
     ndirs←+/ndirs↑~mask

     ⍝ detect clashing names
     allnames←parents('.'U.Join¨)actnames  ⍝ fully qualified names
     :If ∨/mask←(inx←⍳⍨allnames)≠(⍳≢allnames)
         files←allfiles[,(mask/inx),[1.5]⍸mask]
         U.Error'Files produce clashing APL names:',⍕files
     :EndIf

     ⍝ rename files if incorrectly named
     :If opts.forceFilenames∨opts.forceExtensions
         expfiles←⊃¨U.DetermineFileName¨↓⍉↑((≢allfiles)/opts)parents actnames actnames actnc
         :If ∨/mask←expfiles≢¨allfiles
             :If (≢expfiles)≠(≢∪819⌶expfiles)
                 U.Error'Forcing file names would produce clashing file names: use forceFilenames=0 or caseCode=1'
             :Else
                 ⍝ because APL names don't clash, we now expfiles won't clash either
                 ⍝ however expfiles may overlap allfiles, producing an error at intermediate steps (⎕NMOVE should fail, because ⍠'IfExists' 'Error')
                 (mask/expfiles)U.Relocate(mask/allfiles)
                 allfiles←expfiles
             :EndIf
         :EndIf
     :EndIf

     ⍝ create namespaces for directories and load quadVars.apln
     (dirs names)←ndirs↑¨(allfiles allnames)
     :If ~opts.flatten                               ⍝ If we are not flattening, create nss
         nss←U.GetRefTo U.OnEach names
         :If ∨/mask←0=≢¨nss   ⍝ could not create namespace
             inFail,←mask/names ⋄ names/⍨←~mask
         :EndIf
     :Else
         nss←target   ⍝ all files fixed in target namespace
     :EndIf
     {}nss{⎕NEXISTS ⍵:⍺ QFix ⍵ opts ⋄ ⍬}U.OnEach dirs,¨⊂'quadVars.apln' ⍝ set sysvars - these files are produced by Acre and must be supported

     ⍝ fix individual files
     (files names)←ndirs∘↓¨(allfiles allnames)
     TryFixThere←{      ⍝ Try to fix file ⍵ in namespace ⍺
         6 11::⍵        ⍝ return name on failure
         0⊣⍺ QFix ⍵ opts ⍝ do it and return 0 on success
     }
     :If ~opts.flatten                               ⍝ If we are not flattening, create nss
         nss←⍎∘U.Parent U.OnEach names
     :Else
         nss←target   ⍝ all files fixed in target namespace
     :EndIf
     inFail,←0~⍨nss TryFixThere U.OnEach files ⍝ try it and return only failures

     ⍝ return list of failures
     inFail←⍕¨inFail
 :Else
     U.Resignal 1
 :EndTrap
