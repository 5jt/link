 {inFail}←opts FixFiles(target source);FixFile;actnames;actnc;allfiles;allnames;cache;dirs;expfiles;expnames;exts;files;hidden;i;inx;list;mask;names;ndirs;nss;parents;quadfiles;source;tie
 ⍝ Load items from files in folders
 inFail←⍬
 list←↑0 1 6 ⎕NINFO⍠1⍠'Recurse' 1⊢source,'/*'    ⍝ recursive listing of everything  list[filename type hidden;]

 mask←1=list[3;] ⋄ list←¯1↓list                  ⍝ mask for hidden items
 hidden←mask/list ⋄ list/⍨←~mask                 ⍝ crop hidden (files and) folders
 hidden←(1=hidden[2;])/hidden[1;]                ⍝ keep directories only (files have already been removed from list)
 hidden←hidden,¨'/'                              ⍝ protect against similarly named files
 list/⍨←~∨⌿hidden∘.U.Begins list[1;]             ⍝ filter away things that come below hidden directories

 dirs←(1=list[2;])/list[1;]                      ⍝ second column has 1 for dirs
 dirs←((⊂opts.dir),{⍵[⍋⍵]}dirs),¨'/'             ⍝ all directories (including link root)

 files←(2=list[2;])/list[1;]                     ⍝ second column has 2 for files; first column is filename
 files/⍨←opts U.HasExtn files                    ⍝ must be of correct extension
 files←files[U.GradeFiles files]                 ⍝ dirs then quads then files
 :If 0∊⍴files ⋄ :Return ⋄ :EndIf

 ndirs←≢dirs ⋄ allfiles←dirs,files
 cache←opts,opts.(dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite fastLoad)  ⍝ values cached for performance on ns lookup

 (parents expnames actnames actnc)←↓⍉↑cache∘U.DetermineAplNamePart¨allfiles  ⍝ expected names (one per file), actual names (one list per file), actual name classes (one list per file)
 :If opts.fastLoad  ⍝ do not spend time avoiding name clashes - actnc will be all 0's anyway
     allnames←parents('.'U.JoinEach)expnames  ⍝ do not infer true apl name from source
 :Else
     mask←actnc∊¯1 0    ⍝ invalid names or source
     inFail,←mask/allfiles
     (allfiles parents expnames actnames actnc)/⍨←⊂~mask    ⍝ keep only names that are valid
     ndirs←+/ndirs↑~mask
     allnames←parents('.'U.JoinEach)actnames  ⍝ fully qualified names
     :If ∨/mask←(inx←⍳⍨allnames)≠(⍳≢allnames)
         files←allfiles[,(mask/inx),[1.5]⍸mask]
         U.Error'Files produce clashing APL names:',⍕files
     :EndIf
 :EndIf

 ⍝ rename files if incorrectly named - cannot work with opts.fastLoad
 :If (0<≢allfiles)∧opts.(fastLoad<forceExtensions∨forceFilenames)
     expfiles←⊃¨cache∘U.DetermineFileNamePart¨↓⍉↑parents actnames actnames actnc
     expfiles←expfiles(opts.forceFilenames U.MergeFileName opts.forceExtensions)¨allfiles
     :If ∨/mask←expfiles≢¨allfiles
         :If (≢expfiles)≠(≢∪819⌶expfiles)
             U.Error'Forcing file names would produce clashing file names: use forceFilenames=0 or caseCode=1'
         :Else
             ⍝ because APL names don't clash, we now expfiles won't clash either
             ⍝ however expfiles may overlap allfiles, producing an error at intermediate steps (⎕NMOVE should fail, because ⍠'IfExists' 'Error')
             (mask/expfiles)U.Relocate(mask/allfiles)
             allfiles←expfiles
         :EndIf
     :EndIf
 :EndIf

 :If 3=⎕NC opts.beforeRead ⍝ user exit defined?
     mask←(⍴allfiles)⍴1
     :For i :In ⍳⍴allfiles
         ⍝:Trap DEBUG↓0
         mask[i]←(opts⍎opts.beforeRead)'loaded'(i⊃allfiles)(i⊃parents)opts 0 ⍝ return 1 to continue else 0
         ⍝:Else
         ⍝    U.Warn'beforeRead callback ',link.beforeRead,' failed: ',⎕DMX.EM
         ⍝:EndTrap
     :EndFor
     (allfiles parents expnames actnames actnc)/⍨←⊂mask    ⍝ keep what was not processed by user
 :EndIf

 tie←'both' 'ns'∊⍨⊂opts.watch ⍝ tie to file if watching namespace - cached for performance
 FixFile←tie∘{(target file name)←⍵ ⋄ target U.QFix file name ⍺}
 ⍝ create namespaces for directories and load quadVars.apln
 (dirs names)←ndirs↑¨(allfiles allnames)
 :If ~0∊⍴dirs
     :If ~opts.flatten                               ⍝ If we are not flattening, create nss
         nss←names ⎕NS¨⊂⍬
         :If ∨/mask←0=≢¨nss   ⍝ could not create namespace
             inFail,←mask/names
         :EndIf
     :Else
         nss←target   ⍝ all files fixed in target namespace
     :EndIf
     ⍝ set sysvars before anything else - these files are produced by Acre and must be supported
     :If ∨/mask←⎕NEXISTS¨quadfiles←dirs,¨⊂'quadVars.apln'
         mask←mask\~FixFile¨↓nss,mask⌿quadfiles,[1.5]⊂'quadVars'
         inFail,←mask/quadfiles
     :EndIf
 :Else ⋄ quadfiles←0⍴⊂''
 :EndIf

 ⍝ fix individual files
 (files names)←ndirs∘↓¨(allfiles allnames)
 (files names)/⍨←⊂~files∊quadfiles
 :If ~0∊⍴files
     :If ~opts.flatten                               ⍝ If we are not flattening, create nss
         nss←⍎∘U.Parent¨names
     :Else
         nss←target   ⍝ all files fixed in target namespace
     :EndIf
     mask←~FixFile¨↓nss,files,[1.5]names ⍝ try it and return only failures
     inFail,←mask/files
 :EndIf

 ⍝ return list of failures
 inFail←⍕¨inFail
