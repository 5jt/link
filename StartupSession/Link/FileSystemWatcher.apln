:Namespace FileSystemWatcher
    (⎕IO ⎕ML)←1 1
    FSWQ←'⎕SE.Link.FileSystemWatcher.QUEUE' ⍝ FSW Queue Object name prefix
    USE_NQ←1                                ⍝ Set to 0 to make direct calls to Notify

    ∇ NotifyEvent args
     ⍝ Process File System Watcher events, redirected via a timer

     :Select 2⊃args
     :Case 140  ⍝ Timer; do nothing for now
     :Case 7777 ⍝ Re-queued Notify event
         ⎕SE.Link.Notify 3⊃args
     :Case 7778 ⍝ We have been asked to go away
         ⎕EX 1⊃args ⍝ Erase the QUEUE object; WatcherThread will exit from DQ and the :Disposable control structure
     :EndSelect
    ∇

     ∇ WatchEvent(obj args);ct;nargs
     ⍝ Callback for System.IO.FileSystemWatcher instance
     ⍝ Passes info on to ⎕SE.Link.Notify for processing
      
      {}2501⌶0 ⍝ Reap the thread on exit

      nargs←⊂819⌶⍕args.ChangeType
      nargs,←⊂args.FullPath
      :If 0≠⎕NC⊂'args.OldFullPath'
          nargs,←⊂args.OldFullPath
      :EndIf
     
      :If USE_NQ ⍝ Minimise time in .NET callback, enqueue Notify work for later
          ⎕NQ (⊃⎕WN ⎕SE.Link.FileSystemWatcher) 7777 nargs ⍝ Any queue will do 
      :Else      ⍝ Make direct calls to Notify
          ⎕SE.Link.Notify nargs 
      :EndIf
     ∇
 
    ∇r←Watch args;tid;q;z
    ⍝ Set up a file system watcher, return object that will be stored as "fsw" in Link.Links[i]
    
     :If USE_NQ ⍝ Minimise time in .NET callback, enqueue Notify work for later
        z←{0::0 ⋄ 2503⌶⍵}2 ⍝ Children of this thread should not take interrupts
        q←FSWQ,⍕tid←WatcherThread&args
        z←{0::0 ⋄ 2503⌶⍵}z ⍝ Restore thread interruption setting  
        :While 0=⎕NC q
           ⎕DL 0.05
        :EndWhile
        (r←⎕NS '').(QUEUE TID)←q tid ⍝ Return name of QUEUE object and TID ⎕NQ'ing it
     :Else ⍝ Make direct calls to Notify: return the FSW object
        r←MakeWatcher args  
        r.EnableRaisingEvents←1
     :EndIf
    ∇

    ∇ Break fsw;timer;tid;fsw
    ⍝ Cleanly shut down a file system watcher
    ⍝   Called on Links[i].fsw by ⎕SE.Link.Break

     :If 2=⎕NC 'fsw.QUEUE' ⍝ Did we using indirection via a queue?
        (timer tid)←fsw.(QUEUE TID)
        :If tid∊⎕TNUMS
        :AndIf 9=⎕NC timer
           ⎕NQ timer 7778 ⍝ Tell it to go away
           ⎕DL 0.5
           :If tid∊⎕TNUMS
               ⎕TRAP←0 'S' ⋄ ∘∘∘ ⍝ thread won't go
           :EndIf
        :EndIf
     :Else ⍝ Hopefully, fsw is a real FSW object
         fsw.Dispose
     :EndIf
    ∇

    ∇ watcher←MakeWatcher args;dotnetcore;⎕USING
     ⍝ Return a FfileSystemWatcher object
     ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
    
      dotnetcore←(~##.U.isWindows)∨(,'1')≡2 ⎕NQ '.' 'GetEnvironment' 'DYALOG_NETCORE'
      ⎕USING←',System',(~dotnetcore)/'.dll'
      watcher←⎕NEW System.IO.FileSystemWatcher
      watcher.(Path Filter)←args
      watcher.(onChanged onCreated onDeleted onRenamed)←⊂'WatchEvent'
      watcher.IncludeSubdirectories←1
    ∇

    ∇ WatcherThread args;q
     ⍝ Run a thread which creates a FileSystemWatcher object
     ⍝ ... and makes sure there is a ⎕DQ to allow processing of events
      
      :Disposable watcher←MakeWatcher args
          (q←FSWQ,⍕⎕TID) ⎕WC'Timer'('Event'(140 7777 7778)'NotifyEvent')('Interval' 1000)('Data' watcher)
          watcher.EnableRaisingEvents←1
          ⎕DQ q ⍝ Wait here; q will be ⎕EX'd by Link.Break
          watcher.EnableRaisingEvents←0
      :EndDisposable
    ∇

:EndNamespace
