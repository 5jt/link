 outFail←opts WriteFiles(ns dir);dir;files;inx;mask;names;nsref;ok;okFn;okNs;oldfiles;src;tradfiles;tradnames
 ⍝ Write items to file in folders
 ⍝ ns must be a fully specified traditional namespace
 ⍝ arrays not supported
 :If U.debug=2
     (1+⊃⎕LC)⎕STOP⊃⎕SI
 :EndIf
 :Trap DEBUG↓0
     outFail←0⍴⊂''
     okFn←3.1 3.2 4.1 4.2 ⍝ tradfn/dfn/tradop/dop
     okNs←9.1 9.4 9.5 ⍝ ns/class/interface
     nsref←⍎ns

     ⍝ TODO : beforeWrite

     ⍝ Create directory for namesapce
     3 ⎕MKDIR dir
     outFail,←(~⎕NEXISTS dir)/⊂ns  ⍝ can't create directory

     ⍝ Write children to files (except trad namespaces)
     :If 0≠≢names←nsref.⎕NL-okFn,okNs
         src←nsref U.GetAplSource¨names
         mask←0=≢¨src     ⍝ can't get source
         outFail,←(ns,'.')∘,¨mask/names
         (names src)←(~mask)∘/¨(names src)
         (files oldfiles)←↓⍉↑ns∘{U.DetermineFileName opts ⍺ ⍵ ⍵''}¨names  ⍝ names are known to exist so don't provide source
         :If ∨/mask←(inx←⍳⍨819⌶¨files)≠(⍳≢files) ⍝ TODO should really test the whole list of files after recursion, in case beforeWrite messed up the names
             ⍝ cannot let user do this on any platform - if the directory is moved to windows then the user will be screwed
             names←names[,(mask/inx),[1.5]⍸mask]
             U.Error'File name case clash - try using caseCode←1:',⍕(ns,'.')∘,¨names
         :EndIf
         mask←src∊⎕NULL  ⍝ traditional namespaces
         (tradnames tradfiles)←mask∘/¨(names files)
         (files names src)←(~mask)∘/¨(files names src)
         :If 0≠≢files
             mask←src U.Into¨files  ⍝ failed to write
             outFail,←(ns,'.')∘,¨(~mask)/names
             :If ∨/mask←mask∧(oldfiles≢¨files)∧(0≠≢¨oldfiles)  ⍝ delete oldfilename which was incorrect if write was successful
                 ⎕NDELETE¨mask/oldfiles
             :EndIf
         :EndIf
         :If 0≠≢tradfiles ⍝ recurse on traditional namespaces
             tradnames←(ns,'.')∘,¨tradnames
             outFail,←⊃,/opts∘WriteFiles¨↓tradnames,[1.5]tradfiles
         :EndIf
     :EndIf
 :Else
     U.Resignal 1
 :EndTrap
