:Namespace Watcher
    ⎕IO ⎕ML←1 1
    ⎕CT←0  ⍝ to compare EncodeTS
    
    DYALOGVERSION←1 .1+.×2↑⊃(//)'.'⎕VFI 2⊃'.'⎕WG'AplVersion'  ⍝ required at ⎕FIX time - can't rely on ##.U
    IS180←18≤DYALOGVERSION
    IS181←18.1≤DYALOGVERSION
    
    CRAWLER←0                               ⍝ allow using crawler

    
        
    ⍝⍝⍝⍝⍝ .Net System.IO.FileSystemWatcher ⍝⍝⍝⍝⍝
    
    USE_NQ←0                                ⍝ Set to 1 to enqueue calls to Notify via a Timer objecy
    FSWQ←'⎕SE.Link.Watcher.QUEUE'           ⍝ FSW Queue Object name prefix
    
    TimerEvent←140
    NotifyEvent←7777
    CloseEvent←7778
    Timeout←5000       ⍝ Length of timeout waiting for WatcherThread actions
    
    ∇ (dotnet dotnetcore)←HasDotNet;⎕USING
    ⍝ FileSystemWatcher usable only with v18.0 and later
      :If ~IS180    ⍝ Executed at ⎕FIX time, so can't rely on ##.U
          dotnet←dotnetcore←0
      :Else
    ⍝ Assumptions :
    ⍝ Dyalog only allows .Net Framework v4 (v1 v2 and v3.x are not supported anymore)
    ⍝ Therefore v3 and v5 must mean .Net Core
          :Trap 0 ⍝ ⎕USING← has been known to fail
              ⎕USING←''        ⍝ Ensure that System is present if at all possible
              dotnetcore←4≠System.Environment.Version.Major
              ⎕USING←',System',(~dotnetcore)/'.dll'
              dotnet←9.6=⎕NC⊂'System.IO.FileSystemWatcher'
          :Else
              dotnet←dotnetcore←0
          :EndTrap
      :EndIf
    ∇
    (DOTNET DOTNETCORE)←HasDotNet ⍝ cache result
    ∇ canwatch←CanWatch         ⍝ FileSystemWatcher or Crawler
      canwatch←CRAWLER∨DOTNET   ⍝ must be evaluated at runtime to allow ⎕SE.Link.Test to change them
    ∇
    
    
    ∇ RequeuedEvent args
     ⍝ Process events redirected via the timer
      :Select 2⊃args
      :Case TimerEvent  ⍝ Timer; do nothing for now
      :Case NotifyEvent ⍝ Re-queued Notify event
          ##.Notify&3⊃args
      :Case CloseEvent  ⍝ We have been asked to go away
          ⎕EX 1⊃args    ⍝ Erase the QUEUE object; WatcherThread will exit from DQ and the :Disposable control structure
      :EndSelect
    ∇
    
    ∇ WatchEvent(obj args);ct;nargs;timers
     ⍝ Callback for System.IO.FileSystemWatcher instance
     ⍝ Passes info on to ⎕SE.Link.Notify for processing
      {}2501⌶0 ⍝ Reap the thread on exit - triggers mantis 17628
      ⍝{}2502⌶0  ⍝ Discard parked thread - workaround mantis 17628
      nargs←⊂##.U.LCase⍕args.ChangeType
      nargs,←⊂args.FullPath
      :If 0≠⎕NC⊂'args.OldFullPath'
          nargs,←⊂args.OldFullPath
      :EndIf
      :If USE_NQ ⍝ Minimise time in .NET callback, enqueue Notify work for later
         ⍝ Do not split the following line into several lines: thread switch must NOT happen
          :If 0≠≢timers←'Timer'⎕WN ⎕SE.Link.Watcher ⋄ ⎕NQ(⊃timers)NotifyEvent nargs ⋄ :EndIf
      :Else      ⍝ Make direct calls to Notify
          ##.Notify&nargs
      :EndIf
    ∇
    
    ∇ WatchError(obj args);link;msg
      :Hold '⎕SE.Link.Links'
          :If 0∊⍴link←##.U.LookupFile obj.Path
              ##.U.Warn'FileSystemWatcher error on non-linked directory: ',obj.Path
          :Else
              0 Pause link
              msg←⊂'FileSystemWatcher error on linked directory: ',link.dir,' - Link has been paused. To recover, do:'
              msg,←⊂'      ]Link.Refresh ',link.ns,' -source=dir'
              ##.U.Warn 1↓##.U.FmtLines msg
          :EndIf
      :EndHold
    ∇
    
    ∇ WatcherThread args;q;watcher
     ⍝ Run a thread which creates a FileSystemWatcher object
     ⍝ ... makes sure there is a ⎕DQ to allow processing of events
     ⍝ ... and ensures it is disposed of
      :Disposable watcher←MakeWatcher args
          (q←FSWQ,⍕⎕TID)⎕WC'Timer'('Event'(TimerEvent NotifyEvent CloseEvent)'RequeuedEvent')('Interval' 1000)('Data'watcher)
          ⍝ 'Data' for testing purposes.
          watcher.EnableRaisingEvents←1
          ⎕DQ q ⍝ Wait here; q will be ⎕EX'd by Link.Break
          watcher.EnableRaisingEvents←0
          ⎕DL 1 ⍝ Wait for events to stop
      :EndDisposable
    ∇
    
    ∇ watcher←MakeWatcher args;⎕USING
     ⍝ Return a FileSystemWatcher object
     ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
      ⎕USING←',System',(~DOTNETCORE)/'.dll'
      watcher←⎕NEW System.IO.FileSystemWatcher
      watcher.(Path Filter)←args
      watcher.(onChanged onCreated onDeleted onRenamed)←⊂'WatchEvent'
      watcher.onError←'WatchError'
      watcher.IncludeSubdirectories←1
    ∇
    
    
    
    
   ⍝⍝⍝⍝⍝ MAIN API ⍝⍝⍝⍝⍝⍝⍝⍝
    
    ∇ Watch link;args;end;q;r;tid;z
    ⍝ Set up a file system watcher, return object that will be stored as "fsw" in ⎕SE.Link.Links[i]
      :If DOTNET
          args←link.dir(,'*')
          :If USE_NQ ⍝ enqueue Notify work for later: Return NS containing QUEUE name and TID of ⎕DQ'ing thread
              z←{0::0 ⋄ 2503⌶⍵}2 ⍝ Children of this thread should not take interrupts
              q←FSWQ,⍕tid←WatcherThread&args
              z←{0::0 ⋄ 2503⌶⍵}z ⍝ Restore thread interruption setting
              end←Timeout+3⊃⎕AI
              :While 0=⎕NC q ⋄ ⎕DL 0.05 ⋄ :EndWhile    ⍝ Wait for thread to create the Timer object
              (r←⎕NS'').(QUEUE TID)←q tid ⍝ Return name of QUEUE object and TID ⎕NQ'ing it
          :Else ⍝ Make direct calls to Notify: return the FSW object
              r←MakeWatcher args
              r.EnableRaisingEvents←1
          :EndIf
          link.fsw←r
      :ElseIf CRAWLER
          AddCrawler link
      :Else
          ##.U.Error'Cannot watch files'
      :EndIf
    ∇
    
    ∇ watch Pause link;fsw;link
    ⍝ pause/resume file watching
      :If 9=⎕NC'link.fsw.QUEUE'
          fsw←(⍕link.fsw.QUEUE)⎕WG'Data'
      :ElseIf 9=⎕NC'link.fsw'
          fsw←link.fsw
      :EndIf
      :If 0≠⎕NC'fsw'
          fsw.EnableRaisingEvents←watch
      :ElseIf CRAWLER
          watch PauseCrawler link  ⍝ can't hurt if non-crawled link
      :EndIf
    ∇
    ∇ paused←Paused link;fsw
    ⍝ report whether file watching is paused
      :If 9=⎕NC'link.fsw.QUEUE'
          fsw←(⍕link.fsw.QUEUE)⎕WG'Data'
      :ElseIf 9=⎕NC'link.fsw'
          fsw←link.fsw
      :EndIf
      :If 0≠⎕NC'fsw'
          paused←~fsw.EnableRaisingEvents
      :ElseIf CRAWLER
          paused←~IsCrawlerActive link
      :EndIf
    ∇
    
    ∇ Break links;end;tids;timer;timers
    ⍝ Cleanly shut down a file system watcher
    ⍝ Called by ⎕SE.Link.Break
      :If CRAWLER ⋄ RemoveCrawler links ⋄ :EndIf  ⍝ can't hurt of empty links or non-crawled links
      :If ~0∊⍴links
      :AndIf ~0∊⍴links←(9=⌊links.⎕NC⊂⊂'fsw')/links  ⍝ links that have a FSW
          :If USE_NQ ⍝ Did we using indirection via a queue?
              (timers tids)←↓⍉↑links.fsw.(QUEUE TID)
              :If ~0∊⍴timers←(9=⌊⎕NC timers)/timers
                  ⎕NQ¨timers{⍺ ⍵}¨CloseEvent  ⍝ tell timers to go away
              :EndIf
              end←Timeout+3⊃⎕AI
              :While ∨/tids∊⎕TNUMS     ⍝ Wait for thread to create the Timer object
                  ⍝:If end<3⊃⎕AI
                  ⍝    ¯1 ##.U.Warn'WatcherThread ',(⍕⎕TNUMS∩tids),' did not die on request'
                  ⍝:EndIf
                  ⎕DL 0.1
              :EndWhile
              ⎕EX links.fsw.QUEUE
          :Else ⍝ fsw should be a real FSW object
              ⍝ pitfall: must not call Dispose while processing a callback, otherwise the interpreter freezes
              {0::_←0 ⋄ ⍵.EnableRaisingEvents←0}¨links.fsw  ⍝ at )CLEAR time, .Net object might throw EXCEPTION: Object reference not set to an instance of an object.
              ⎕DL 0.1 ⍝ Give any extant events time to be processed
              {0::_←0 ⋄ _←⍵⍎'Dispose ⋄ 0'}¨links.fsw  ⍝ at )CLEAR time, .Net object might throw EXCEPTION: Object reference not set to an instance of an object.
          :EndIf
          links.fsw←⊂⍬
      :EndIf
    ∇
    
    
    
    
    
    
    
    
    
    
    
    
    ⍝⍝⍝⍝⍝ Crawler ⍝⍝⍝⍝⍝
    ⍝ Crawls BOTH the namespace and the directory
    ⍝ Will always fully crawl when interpreter comes back to descalc
    
    ⍝ Issues :
    ⍝ - Crawler should ignore -fastLoad ?
    ⍝ - Crawl should be allowed to fail once (race condition) before timer is de-activated (on second failure in a row)
    ⍝ - Comparing source is slow
    ⍝ - Looking for files with 5174⌶ is slow
    ⍝ - To compare sources, APL must NOT be tied to files
    ⍝ - Do a single ⎕NINFO to get timestamps too
    ⍝ - Synchronising the ⎕NINFO with the ⎕NGET
    
    LOGCRAWLER←1  ⍝ Log crawler-specific internals - undesirable unless debugging the crawler itself
    
    ∇ time←EncodeTS TS        ⍝ time in seconds
      time←0.001×0 12 31 24 60 60 1000⊥⍉↑⊆TS  ⍝ takes about 14 digits - ⎕CT must be zero
    ∇
    TS_OLD←EncodeTS 0  ⍝ old timestamp
    ∇ ts←TS  ⍝ Time stamp in seconds
      ts←EncodeTS ⎕TS
    ∇
    
    LINKS←3 0⍴⍬  ⍝ [link items active;]
    L_LINK L_ITEMS L_ACTIVE←⍳3
    NO_ITEMS←5 0⍴⍬  ⍝ [file name nc checked filemod;]
    I_FILE I_NAME I_NC I_CHECKED I_FMOD←⍳5
    LASTSTART←LASTEND←TS_OLD
    
    INTERVAL←3⊣.1    ⍝ Timer interval in seconds
    GRANULARITY←.02  ⍝ Time granularity in seconds - as bad as 20ms on Windows
    ∇ timer←CreateTimer;args
    ⍝ create Timer in thread 0, so that timer events will be generated when thread 0 comes back to six-space prompt
      :If 0≠⎕TID ⋄ (⎕←'⎕SE.Link.Watcher namespace must be fixed in thread 0')⎕SIGNAL 999 ⋄ :EndIf
      args←('Active' 0)('Interval'(⌈1000×INTERVAL))('Event'('onTimer' 'CrawlerEvent'))
      :If IS181 ⋄ args,←⊂('FireOnce' 1) ⋄ :EndIf
      timer←⎕NEW'Timer'args
    ∇
    TIMER←CreateTimer
    ⍝ There is one message queue per thread for APL events/callbacks
    ⍝ Objects will only see the message queue of the thread that created it (by calling ⎕NEW, ⎕WC, etc.)
    ⍝ When the thread is destroyed ;
    ⍝ - we don't know whether it (hands the queue to the parent thread) or (destroys the queue)
    ⍝ - future events will be passed to the parent thread
    ⍝ The message queue is processed :
    ⍝ - When the thread reaches descalc (size space prompt) (there can only be one thread in descalc at any given time)
    ⍝    (unless there is a ⎕DQ on the stack, so while we are tracing)
    ⍝ - its thread is running ⎕DQ
    
    
    ∇ warn LogCrawler msg;title
    ⍝ Use 1 to warn, 0 to log link-specific events, ¯1 to log crawler-specific events
      title←'⎕SE.Link.Crawler'
      :If (warn=1) ⋄ title ##.U.Warn msg
      :ElseIf (warn=0)∨(LOGCRAWLER∧warn=¯1) ⋄ title ##.U.Log msg
      :EndIf
    ∇
    
    ∇ AddCrawler link;args
      :Hold '⎕SE.Link.Crawler'
          ¯1 LogCrawler'Adding link: 'link' to ',LINKS[L_LINK;]
          LINKS,←link NO_ITEMS 1
          Crawl link  ⍝ set up
          :If ~TIMER.Active
              TIMER.Interval←⌈1000×INTERVAL  ⍝ for ⎕SE.Link.Test to change it
              TIMER.Active←1
              ¯1 LogCrawler'Started timer'
          :EndIf
      :EndHold
    ∇
    ∇ active PauseCrawler links;inx;mask
      :Hold '⎕SE.Link.Crawler'
          :If ∨/mask←LINKS[L_LINK;]∊links
              LINKS[L_ACTIVE;⍸mask]←1 ⍝ update all states when pausing or unpausing
              Crawl¨LINKS[L_LINK;⍸mask]
              LINKS[L_ACTIVE;⍸mask]←mask/active
          :EndIf
      :EndHold
    ∇
    ∇ active←IsCrawlerActive links;mask
      :Hold '⎕SE.Link.Crawler'
          mask←LINKS[;L_LINK]∊links
          active←mask\LINKS[L_ACTIVE;⍸mask]
      :EndHold
    ∇
    ∇ RemoveCrawler links;msg
      :Hold '⎕SE.Link.Crawler'
          LINKS/⍨←~LINKS[L_LINK;]∊links
          ¯1 LogCrawler(⊂'Removing link: '),links,(⊂' - Remaining links: '),(LINKS[L_LINK;])
          :If 0∊⍴LINKS
              TIMER.Active←0
              ¯1 LogCrawler'Stopping timer'
          :EndIf
      :EndHold
    ∇
    
    
    
    ∇ {msg}←CrawlerEvent msg;mask;ok;start
      :If ##.U.debug=2
          (1+⊃⎕LC)⎕STOP⊃⎕SI
      :EndIf
      :Trap ##.DEBUG↓0
          start←TS
          :If ~IS181  ⍝ v18.1 has FireOnce property so events never pile up
          :AndIf (INTERVAL-GRANULARITY)>(start-LASTSTART)  ⍝ prevent running several events in a row when the queue has piled up
              ¯1 LogCrawler'Timer event: Event queue overloaded'
              :Return
          :ElseIf (0.5×INTERVAL)>(start-LASTEND)  ⍝ prevent spending more than half the time crawling
              ¯1 LogCrawler'Timer event: Crawler overloaded'
          :EndIf
          ¯1 LogCrawler'Timer event'
          :Hold '⎕SE.Link.Crawler' '⎕SE.Link.Notify'
          ⍝ Crawl must call Notify directly for the :Hold to work !
              :If 1∊mask←LINKS[L_ACTIVE;]
                  Crawl¨mask/LINKS[L_LINK;]
              :EndIf
          :EndHold
          :If IS181  ⍝ v18.1 has FireOnce property so set it up again
              (⊃msg).FireOnce←1  ⍝ fire once more
          :EndIf
          LASTSTART←start
          LASTEND←TS
      :Else
          (⊃msg).Active←0
          ⎕←'Link: Crawler callback internal error - Crawler stopped'
      :EndTrap
    ∇
    
    ∇ {crawled}←Crawl link;active;actname;allfiles;apllist;aplnames;aplnc;aplsrc;changed;changedfiles;changedinx;changedmod;changednames;changednc;changedsrc;delfiles;delmask;delnames;differ;dirs;expname;filelist;filemod;filenames;filesrc;inx;items;mask;mewmod;mod;modmask;nc;newfiles;newmask;newmod;newnames;newnc;newsrc;notchecked;ns;nsref;oldfiles;oldnames;src;watchdir;watchns;where
    ⍝ crawler must keep track of files changes even if not watching dir, to be able to interpret APL changes correctly
      crawled←0 ⋄ watchdir←'dir' 'both'∊⍨⊂link.watch ⋄ watchns←'ns' 'both'∊⍨⊂link.watch
      :If (⊃⌽⍴LINKS)<inx←LINKS[L_LINK;]⍳link
          1 LogCrawler'Link not crawled: '(,⍕link)  ⍝ should not happen
          :Return
      :EndIf
      (link items active)←LINKS[;inx]
      :If ~active  ⍝ should not happen
          1 LogCrawler'Link not active: '(,⍕link)
      :EndIf
      crawled←1 ⋄ nsref←⍎ns←link.ns ⋄ items[I_CHECKED;]←0
      ⍝ avoid thread-switch across the next line
      (filelist dirs filemod)←link(1 ##.U.ListFiles)link.dir ⋄ (apllist aplnc)←2↑0 ##.U.ListLinkedNs link
      filemod←EncodeTS↑filemod
      (filelist dirs filemod)/⍨←⊂~filelist∊⊂link.dir,'/'  ⍝ do not keep track of root
      (filelist filemod){⍺[⍵]}←⊂⍒dirs ⋄ dirs←(+/dirs)↑filelist ⍝ keep dirs first
      :If 1
      ⍝⍝⍝ Look for creation/deletion of files (modification may be old in case unzipped)
      ⍝ look files before APL because user may have special handling such as "*.charmat" with beforeread/beforewrite, yet without providing proper getFilename
      ⍝ do deletions before creations for rename to work
          oldfiles←items[I_FILE;]
          newfiles←newnames←newnc←newmod←⍬
          :If 1∊delmask←~oldfiles∊filelist
              delfiles←delmask/oldfiles
              :If watchdir
                  delnames←##.Notify¨{'deleted'⍵}¨⌽delfiles  ⍝ delete directories last
              :EndIf
          :EndIf
          :If 1∊newmask←~filelist∊oldfiles
              newfiles←newmask/filelist
              newmod←newmask/filemod
              :If watchdir
                  newnames←##.Notify¨{'created'⍵}¨newfiles  ⍝ create directories first
                  newnc←# ##.U.NameClass¨newnames
              :Else
                  (where expname actname newnc)←link ##.U.DetermineAplName newfiles
                  newnames←where('.'##.U.JoinEach)actname
              :EndIf
              (newfiles newnames newnc newmod)/⍨←⊂~(newnc∊0 ¯1)∨(0=≢¨newnames)  ⍝ ignore unidentifiable files
              delmask∨←(items[I_NAME;]∊newnames~⊂'') ⍝ remove previous entries on those names
          :EndIf
          ⍝ update data structures
          (apllist aplnc)/⍨←⊂~apllist∊items[I_NAME;⍸delmask]  ⍝ remove deleted objects for list
          (apllist aplnc),←(newnames newnc)                   ⍝ add created objects to list
          items←((~delmask)/items),↑newfiles newnames newnc((≢newfiles)⍴1)newmod
      :EndIf
      :If watchns
      ⍝⍝⍝ Look for creation/deletion of APL names
      ⍝ names created by file detection won't be created again
          oldnames←items[I_NAME;]
          ⍝ check for deletions
          delmask←~oldnames∊apllist,⊂''   ⍝ files that don't have a proper name (oldname≡'') don't contribute to APL deletions !
          :If 1∊mask←2.1=items[I_NC;⍸delmask]  ⍝ double-check deletion of variable
              delmask∧←delmask\mask\0=#.⎕NC mask/delmask/oldnames    ⍝ variables in directory may not appear in ListLinkedNs - delete only if name class is zero
          :EndIf
          :If 1∊delmask ⋄ :AndIf watchns
              delfiles←⊃link(1 ##.U.DetermineFileName)((+/delmask)⍴⊂ns)((1+≢ns)↓¨delmask/oldnames)((+/delmask)⍴⊂'')(delmask/items[I_NC;])
              allfiles←4⊃¨5177⌶⍬
              :If 1∊mask←delfiles∊allfiles  ⍝oldfiles∩allfiles  ⍝ some oldfiles still tied - should not happen
                  (mask/delmask/oldnames){1 LogCrawler'Deleted APL item: file still in use: '⍺' → '⍵}¨(mask/delfiles)
              :EndIf
              :If 1∊mask←~mask  ⍝~0∊⍴lostfiles←oldfiles~allfiles  ⍝ delete oldfiles that are not tied to anything
                  (mask/delmask/oldnames){0 LogCrawler'Deleted APL item: '⍺' → '⍵}¨(mask/delfiles)
                  3 ⎕NDELETE⌽(mask/delfiles)  ⍝ delete directories last
              :EndIf
          :EndIf
          ⍝ check for creations
          newnc←newfiles←newnames←newmod←⍬
          :If 1∊mask←~apllist∊oldnames
              (newnames newnc)←mask∘/¨(apllist aplnc)
              :If ∨/mask←{1=≡⍵}¨newsrc←nsref ##.U.GetAplSource¨newnames
                  ¯1 LogCrawler'Failures to get APL source:',⍕mask/newnames
                  (newnames newnc newsrc)/⍨←⊂~mask
              :EndIf
          :AndIf ~0∊⍴newnames
              newfiles←⊃link(1 ##.U.DetermineFileName)((≢newnames)⍴⊂ns)((1+≢ns)↓¨newnames)((≢newnames)⍴⊂'')newnc
              newnames{0 LogCrawler'Created APL item: '⍺' → '⍵}¨newfiles
              ⍝ avoid thread-switch across the next two line
              newsrc ##.U.Into¨newfiles ⋄ newmod←EncodeTS↑3 ⎕NINFO newfiles
              delmask∨←(items[I_FILE;]∊newfiles)  ⍝ remove previous entries on those files - newfiles can never be ''
          :EndIf
          ⍝ update data structure
          (filelist filemod)/⍨←⊂~filelist∊items[I_FILE;⍸delmask]   ⍝ remove deleted files from list
          (filelist filemod),←(newfiles newmod)                    ⍝ add created files to list          
          items←((~delmask)/items),↑newfiles newnames newnc((≢newnames)⍴1)newmod
      :EndIf
      :If 1
      ⍝⍝⍝ Look for files (not dirs) with a change of modification timestamp
          changed←filelist∊oldfiles←(~items[I_CHECKED;])/items[I_FILE;]
          :If ~0∊⍴changedfiles←changed/filelist
              changedmod←changed/filemod
              changedinx←oldfiles⍳changedfiles
          :AndIf 1∊modmask←changedmod≠¨items[I_FMOD;changedinx]  ⍝ file modification timestamp has changed
          :AndIf 1∊modmask←modmask∧(¯9.1≠items[I_NC;changedinx])∨(~changedfiles∊dirs)  ⍝ ignore change of timestamps for dirs that remain dirs
              changednames←##.Notify¨{'changed'⍵}¨modmask/changedfiles
              ⍝ update data structure
              mask←~items[I_NAME;]∊changednames  ⍝ delete entries
              mask[modmask/changedinx]←1         ⍝ excepted self
              items[I_NAME I_CHECKED I_FMOD;modmask/changedinx]←↑changednames((+/modmask)⍴1)(modmask/changedmod)
              items/⍨←mask
          :EndIf
      :EndIf
      :If watchns
      ⍝⍝⍝ Look for content difference between APL and files
      ⍝ assume that if file modification timestamp hasn't changed,
      ⍝ then in case of difference the APL side is the "new" one.
      ⍝ this is why we must keep tracking dir even when no watching it
          differ←notchecked←⍬
          :If ~0∊⍴items  ⍝ otherwise  items[I_CHECKED;]  may have nested prototype
              mask←~items[I_CHECKED;]     ⍝ items not checked so far
              mask∧←0<≢¨items[I_NAME;]    ⍝ items that have a valid APL name
          :AndIf ~0∊⍴notchecked←⍸mask
              ⍝ avoid thread switch over the next line
              aplsrc←# ##.U.GetAplSource¨aplnames←items[I_NAME;notchecked] ⋄ filesrc←##.U.GetFileSource¨filenames←items[I_FILE;notchecked] ⋄ nc←# ##.U.NameClass¨aplnames
              :If ∨/mask←{1=≡⍵}¨aplsrc ⋄ ¯1 LogCrawler'Failures to get APL source:',⍕mask/aplnames ⋄ :EndIf
              :If ∨/mask←{1=≡⍵}¨filesrc ⋄ ¯1 LogCrawler'Failures to get file source:',⍕mask/filenames ⋄ :EndIf
              mask←aplsrc≢¨filesrc             ⍝ items that differ from file definition
              mask∧←⊃∧/~{1=≡⍵}¨¨aplsrc filesrc ⍝ ignore failures to get source on either side (probably a deletion, handled at next crawl)
          :AndIf ~0∊⍴differ←mask/notchecked
              (mask/aplnames){0 LogCrawler'Changed APL item: '⍺' → '⍵}¨(mask/filenames)
              ⍝ avoid switching thread between the file write and the ⎕NINFO
              (mask/aplsrc)##.U.Into¨(mask/filenames) ⋄ mod←EncodeTS↑3 ⎕NINFO mask/filenames
              ⍝ update datastructure
              items[;differ]←↑(mask/filenames)(mask/aplnames)(mask/nc)((+/mask)⍴1)mod
          :EndIf
      :EndIf
    ⍝⍝⍝ Update global data structure
      :If {(≢¨∪¨⍵)≢(≢¨⍵)}(↓2↑items)~¨⊂⊂''
          ##.U.Error'Internal error: non-unique items'
      :EndIf
      LINKS[;inx]←link items active
      ⍝##.U.Log'Items: ',(⍕⊃⌽⍴items),' ⋄ Source compared: ',(⍕≢notchecked),' ⋄ Differ: ',(⍕≢differ)
    ∇
    
    
:EndNamespace
