:Namespace Watcher
    ⎕IO ⎕ML←1 1
    ⎕CT←0  ⍝ to compare EncodeTS

    DYALOGVERSION←1 .1+.×2↑⊃(//)'.'⎕VFI 2⊃'.'⎕WG'AplVersion'  ⍝ required at ⎕FIX time - can't rely on ##.U
    IS180←18≤DYALOGVERSION
    IS181←18.1≤DYALOGVERSION

    CRAWLER←0                               ⍝ allow using crawler


    ⍝⍝⍝⍝⍝ .Net System.IO.FileSystemWatcher ⍝⍝⍝⍝⍝

    USE_NQ←0                                ⍝ Set to 1 to enqueue calls to Notify via a Timer objecy
    FSWQ←'⎕SE.Link.Watcher.QUEUE'           ⍝ FSW Queue Object name prefix

    TimerEvent←140
    NotifyEvent←7777
    CloseEvent←7778
    Timeout←5000       ⍝ Length of timeout waiting for WatcherThread actions

    ∇ (dotnet dotnetcore)←HasDotNet;⎕USING
    ⍝ FileSystemWatcher usable only with v18.0 and later
      :If ~IS180    ⍝ Executed at ⎕FIX time, so can't rely on ##.U
          dotnet←dotnetcore←0
      :Else
    ⍝ Assumptions :
    ⍝ Dyalog only allows .Net Framework v4 (v1 v2 and v3.x are not supported anymore)
    ⍝ Therefore v3 and v5 must mean .Net Core
          :Trap 0 ⍝ ⎕USING← has been known to fail
              ⎕USING←''        ⍝ Ensure that System is present if at all possible
              dotnetcore←4≠System.Environment.Version.Major
              ⎕USING←',System',(~dotnetcore)/'.dll'
              dotnet←9.6=⎕NC⊂'System.IO.FileSystemWatcher'
          :Else
              dotnet←dotnetcore←0
          :EndTrap
      :EndIf
    ∇
    (DOTNET DOTNETCORE)←HasDotNet ⍝ cache result
    ∇ canwatch←CanWatch         ⍝ FileSystemWatcher or Crawler
      canwatch←CRAWLER∨DOTNET   ⍝ must be evaluated at runtime to allow ⎕SE.Link.Test to change them
    ∇


    ∇ RequeuedEvent args
     ⍝ Process events redirected via the timer
      :Select 2⊃args
      :Case TimerEvent  ⍝ Timer; do nothing for now
      :Case NotifyEvent ⍝ Re-queued Notify event
          ##.Notify&3⊃args
      :Case CloseEvent  ⍝ We have been asked to go away
          ⎕EX 1⊃args    ⍝ Erase the QUEUE object; WatcherThread will exit from DQ and the :Disposable control structure
      :EndSelect
    ∇

    ∇ WatchEvent(obj args);ct;nargs;timers
     ⍝ Callback for System.IO.FileSystemWatcher instance
     ⍝ Passes info on to ⎕SE.Link.Notify for processing
      {}2501⌶0 ⍝ Reap the thread on exit - triggers mantis 17628
      ⍝{}2502⌶0  ⍝ Discard parked thread - workaround mantis 17628
      nargs←⊂##.U.LCase⍕args.ChangeType
      nargs,←⊂args.FullPath
      :If 0≠⎕NC⊂'args.OldFullPath'
          nargs,←⊂args.OldFullPath
      :EndIf
      :If USE_NQ ⍝ Minimise time in .NET callback, enqueue Notify work for later
         ⍝ Do not split the following line into several lines: thread switch must NOT happen
          :If 0≠≢timers←'Timer'⎕WN ⎕SE.Link.Watcher ⋄ ⎕NQ(⊃timers)NotifyEvent nargs ⋄ :EndIf
      :Else      ⍝ Make direct calls to Notify
          ##.Notify&nargs
      :EndIf
    ∇

    ∇ WatchError(obj args);link;msg
      :Hold '⎕SE.Link.Links'
          :If 0∊⍴link←##.U.LookupFile obj.Path
              ##.U.Warn'FileSystemWatcher error on non-linked directory: ',obj.Path
          :Else
              0 Pause link
              msg←⊂'FileSystemWatcher error on linked directory: ',link.dir,' - Link has been paused. To recover, do:'
              msg,←⊂'      ]Link.Refresh ',link.ns,' -source=dir'
              ##.U.Warn 1↓##.U.FmtLines msg
          :EndIf
      :EndHold
    ∇

    ∇ WatcherThread args;q;watcher
     ⍝ Run a thread which creates a FileSystemWatcher object
     ⍝ ... makes sure there is a ⎕DQ to allow processing of events
     ⍝ ... and ensures it is disposed of
      :Disposable watcher←MakeWatcher args
          (q←FSWQ,⍕⎕TID)⎕WC'Timer'('Event'(TimerEvent NotifyEvent CloseEvent)'RequeuedEvent')('Interval' 1000)('Data'watcher)
          ⍝ 'Data' for testing purposes.
          watcher.EnableRaisingEvents←1
          ⎕DQ q ⍝ Wait here; q will be ⎕EX'd by Link.Break
          watcher.EnableRaisingEvents←0
          ⎕DL 1 ⍝ Wait for events to stop
      :EndDisposable
    ∇

    ∇ watcher←MakeWatcher args;⎕USING
     ⍝ Return a FileSystemWatcher object
     ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
      ⎕USING←',System',(~DOTNETCORE)/'.dll'
      watcher←⎕NEW System.IO.FileSystemWatcher
      watcher.(Path Filter)←args
      watcher.(onChanged onCreated onDeleted onRenamed)←⊂'WatchEvent'
      watcher.onError←'WatchError'
      watcher.IncludeSubdirectories←1
    ∇




   ⍝⍝⍝⍝⍝ MAIN API ⍝⍝⍝⍝⍝⍝⍝⍝

    ∇ Watch link;args;end;q;r;tid;z
    ⍝ Set up a file system watcher, return object that will be stored as "fsw" in ⎕SE.Link.Links[i]
      :If DOTNET
          args←link.dir(,'*')
          :If USE_NQ ⍝ enqueue Notify work for later: Return NS containing QUEUE name and TID of ⎕DQ'ing thread
              z←{0::0 ⋄ 2503⌶⍵}2 ⍝ Children of this thread should not take interrupts
              q←FSWQ,⍕tid←WatcherThread&args
              z←{0::0 ⋄ 2503⌶⍵}z ⍝ Restore thread interruption setting
              end←Timeout+3⊃⎕AI
              :While 0=⎕NC q ⋄ ⎕DL 0.05 ⋄ :EndWhile    ⍝ Wait for thread to create the Timer object
              (r←⎕NS'').(QUEUE TID)←q tid ⍝ Return name of QUEUE object and TID ⎕NQ'ing it
          :Else ⍝ Make direct calls to Notify: return the FSW object
              r←MakeWatcher args
              r.EnableRaisingEvents←1
          :EndIf
          link.fsw←r
      :ElseIf CRAWLER
          AddCrawler link
      :Else
          ##.U.Error'Cannot watch files'
      :EndIf
    ∇

    ∇ watch Pause link;fsw;link
    ⍝ pause/resume file watching
      :If 9=⎕NC'link.fsw.QUEUE'
          fsw←(⍕link.fsw.QUEUE)⎕WG'Data'
      :ElseIf 9=⎕NC'link.fsw'
          fsw←link.fsw
      :EndIf
      :If 0≠⎕NC'fsw'
          fsw.EnableRaisingEvents←watch
      :ElseIf CRAWLER
          watch PauseCrawler link  ⍝ can't hurt if non-crawled link
      :EndIf
    ∇
    ∇ paused←Paused link;fsw
    ⍝ report whether file watching is paused
      :If 9=⎕NC'link.fsw.QUEUE'
          fsw←(⍕link.fsw.QUEUE)⎕WG'Data'
      :ElseIf 9=⎕NC'link.fsw'
          fsw←link.fsw
      :EndIf
      :If 0≠⎕NC'fsw'
          paused←~fsw.EnableRaisingEvents
      :ElseIf CRAWLER
          paused←~IsCrawlerActive link
      :EndIf
    ∇

    ∇ Break links;end;tids;timer;timers
    ⍝ Cleanly shut down a file system watcher
    ⍝ Called by ⎕SE.Link.Break
      :If CRAWLER ⋄ RemoveCrawler links ⋄ :EndIf  ⍝ can't hurt of empty links or non-crawled links
      :If ~0∊⍴links
      :AndIf ~0∊⍴links←(9=⌊links.⎕NC⊂⊂'fsw')/links  ⍝ links that have a FSW
          :If USE_NQ ⍝ Did we using indirection via a queue?
              (timers tids)←↓⍉↑links.fsw.(QUEUE TID)
              :If ~0∊⍴timers←(9=⌊⎕NC timers)/timers
                  ⎕NQ¨timers{⍺ ⍵}¨CloseEvent  ⍝ tell timers to go away
              :EndIf
              end←Timeout+3⊃⎕AI
              :While ∨/tids∊⎕TNUMS     ⍝ Wait for thread to create the Timer object
                  ⍝:If end<3⊃⎕AI
                  ⍝    ¯1 ##.U.Warn'WatcherThread ',(⍕⎕TNUMS∩tids),' did not die on request'
                  ⍝:EndIf
                  ⎕DL 0.1
              :EndWhile
              ⎕EX links.fsw.QUEUE
          :Else ⍝ fsw should be a real FSW object
              ⍝ pitfall: must not call Dispose while processing a callback, otherwise the interpreter freezes
              {0::_←0 ⋄ ⍵.EnableRaisingEvents←0}¨links.fsw  ⍝ at )CLEAR time, .Net object might throw EXCEPTION: Object reference not set to an instance of an object.
              ⎕DL 0.1 ⍝ Give any extant events time to be processed
              {0::_←0 ⋄ _←⍵⍎'Dispose ⋄ 0'}¨links.fsw  ⍝ at )CLEAR time, .Net object might throw EXCEPTION: Object reference not set to an instance of an object.
          :EndIf
          links.fsw←⊂⍬
      :EndIf
    ∇












    ⍝⍝⍝⍝⍝ Crawler ⍝⍝⍝⍝⍝
    ⍝ Crawls BOTH the namespace and the directory
    ⍝ Will always fully crawl when interpreter comes back to descalc
    ⍝ v18.1 required for Timer.FireOnce←1
    ⍝ TODO v18.0 and earlier need to check that the last timer event was reasonably long ago to crawl only once when catching up the piled queue of timer events when coming back to descalc

    LOGCRAWLER←1  ⍝ Log crawler-specific internals - undesirable unless debugging the crawler itself

    ⍝Time←{.001×3⊃⎕AI}  ⍝ time in seconds
    ∇ time←EncodeTS TS        ⍝ time in milliseconds
      time←0.001×0 12 31 24 60 60 1000⊥⍉↑⊆TS  ⍝ takes about 14 digits - ⎕CT must be zero
    ∇
    TS_OLD←EncodeTS 0  ⍝ old timestamp
    ∇ ts←TS  ⍝ Time stamp in milliseconds
      ts←EncodeTS ⎕TS
    ∇


    LINKS←4 0⍴⍬  ⍝ [link items check active;]
    L_LINK L_ITEMS L_CHECK L_ACTIVE←⍳4
    NO_ITEMS←5 0⍴⍬  ⍝ [file name nc check filemod;]
    I_FILE I_NAME I_NC I_CHECK I_FMOD←⍳5
    LASTEND←TS_OLD

    TIMER←⎕NULL
    INTERVAL←2000⊣100    ⍝ Timer interval in milliseconds
    GRANULARITY←20  ⍝ Time granularity in milliseconds

    ∇ warn LogCrawler msg;title
    ⍝ Use 1 to warn, 0 to log link-specific events, ¯1 to log crawler-specific events
      title←'⎕SE.Link.Crawler'
      :If (warn=1) ⋄ title ##.U.Warn msg
      :ElseIf (warn=0)∨(LOGCRAWLER∧warn=¯1) ⋄ title ##.U.Log msg
      :EndIf
    ∇

    ∇ AddCrawler link;args
      :Hold '⎕SE.Link.Crawler'
          ¯1 LogCrawler'Adding link: 'link' to ',LINKS[L_LINK;]
          LINKS,←link NO_ITEMS TS_OLD 1
          Crawl link  ⍝ set up
          :If ⎕NULL≡TIMER
              args←('Interval'(⌈INTERVAL))('Event'('onTimer' 'CrawlerEvent&'))('Active' 1)  ⍝ trigger event in a parallel thread to avoid DEADLOCK on ⎕SE.Link.Crawler  
              :If IS181 ⋄ args,←⊂('FireOnce' 1) ⋄ :EndIf
              TIMER←⎕NEW'Timer'args
              ¯1 LogCrawler'Started timer'
          :EndIf
      :EndHold
    ∇
    ∇ active PauseCrawler links;inx;mask
      :Hold '⎕SE.Link.Crawler'
          mask←LINKS[L_LINK;]∊links
          LINKS[L_ACTIVE;⍸mask]←mask/active
      :EndHold
    ∇
    ∇ active←IsCrawlerActive links;mask
      :Hold '⎕SE.Link.Crawler'
          mask←LINKS[;L_LINK]∊links
          active←mask\LINKS[L_ACTIVE;⍸mask]
      :EndHold
    ∇
    ∇ RemoveCrawler links;msg
      :Hold '⎕SE.Link.Crawler'
          LINKS/⍨←~LINKS[L_LINK;]∊links
          ¯1 LogCrawler(⊂'Removing link: '),links,(⊂'- Remaining links: '),(LINKS[L_LINK;])
          :If (0∊⍴LINKS)∧(TIMER≢⎕NULL)
              TIMER.Active←0 ⋄ TIMER←⎕NULL
              ¯1 LogCrawler'Stopping timer'
          :EndIf
      :EndHold
    ∇



    ∇ {msg}←CrawlerEvent msg
      :If ~IS181  ⍝ v18.1 has FireOnce property so events never pile up
      :AndIf (INTERVAL-GRANULARITY)>(TS-LASTEND)  ⍝ wait at least INTERVAL since last crawl to crawl again
          ¯1 LogCrawler'Crawler timer overloaded'
          :Return
      :EndIf
      :Hold '⎕SE.Link.Crawler' '⎕SE.Link.Notify'
          Crawl¨LINKS[L_LINK;]  ⍝ Crawl must call Notify directly for the :Hold to work !
      :EndHold
      LASTEND←TS
      :If IS181  ⍝ v18.1 has FireOnce property so set it up again
          (⊃msg).FireOnce←1  ⍝ fire once more
      :EndIf
    ∇

    ∇ {start}←Crawl link;active;allfiles;aplnames;aplsrc;changedfiles;changedinx;changedmod;changednames;changednc;changedsrc;check;creations;deletions;delfiles;delmask;delnames;differ;filenames;filesrc;inx;items;mask;mewmod;mod;modmask;newdirs;newfiles;newmod;newnames;newnc;newsrc;notchecked;ns;nsref;oldfiles;oldnames;src;start;time
      start←TS
      :If (⊃⌽⍴LINKS)<inx←LINKS[L_LINK;]⍳link
          1 LogCrawler'Link not crawled: '(,⍕link)  ⍝ should not happen
          :Return
      :EndIf
      (link items check active)←LINKS[;inx]
      :If ~active
          ¯1 LogCrawler'Link not active: '(,⍕link)
      :EndIf
    ⍝⍝⍝ Look for creation/deletion of APL names
      time←TS
      nsref←⍎ns←link.ns
      newnames←1 ##.U.ListNs ns
      oldnames←items[I_NAME;]
      ⍝ check for creations
      newnc←newfiles←newmod←⍬
      :If ~0∊⍴creations←newnames~oldnames
          newsrc←nsref ##.U.GetAplSource¨creations
          newnc←nsref ##.U.NameClass¨creations
          newfiles←⊃link(1 ##.U.DetermineFileName)((≢creations)⍴⊂ns)((1+≢ns)↓¨creations)((≢creations)⍴⊂'')newnc
          creations{0 LogCrawler'Created APL item: '⍺' → '⍵}¨newfiles
          newsrc ##.U.Into¨newfiles
          newmod←EncodeTS↑3 ⎕NINFO newfiles
      :EndIf
      ⍝ check for deletions
      oldfiles←⍬
      deletions←oldnames~newnames
      :If 1∊delmask←oldnames∊deletions
          oldfiles←⊃link(1 ##.U.DetermineFileName)((+/delmask)⍴⊂ns)((1+≢ns)↓¨delmask/oldnames)((+/delmask)⍴⊂'')(delmask/items[I_NC;])
          allfiles←4⊃¨5177⌶⍬
          :If 1∊mask←oldfiles∊allfiles  ⍝oldfiles∩allfiles  ⍝ some oldfiles still tied - should not happen
              (mask/delmask/oldnames){1 LogCrawler'Deleted APL item: file still in use: '⍺' → '⍵}¨(mask/oldfiles)
          :EndIf
          :If 1∊mask←~mask  ⍝~0∊⍴lostfiles←oldfiles~allfiles  ⍝ delete oldfiles that are not tied to anything
              (mask/delmask/oldnames){0 LogCrawler'Deleted APL item: '⍺' → '⍵}¨(mask/oldfiles)
              3 ⎕NDELETE⌽(mask/oldfiles)  ⍝ delete directories last
          :EndIf
      :EndIf
      ⍝ update data structure
      items←((~delmask)/items),↑newfiles creations newnc((≢creations)⍴⊂time)newmod
    ⍝⍝⍝ Look for files (not dirs) with a change of modification timestamp
      time←TS
      (newfiles newdirs)←link ##.U.ListFiles link.dir
      (newfiles newdirs)←(0 1=⊂newdirs)/¨⊂newfiles
      newdirs~←⊂link.dir,'/'  ⍝ do not keep track of root
      newfiles←newdirs,newfiles  ⍝ keep dir first
      oldfiles←items[I_FILE;]
      delfiles←oldfiles~newfiles ⋄ changedfiles←newfiles∩oldfiles ⋄ newfiles~←oldfiles
      :If ~0∊⍴changedfiles
          changedmod←EncodeTS↑3 ⎕NINFO changedfiles
          changedinx←oldfiles⍳changedfiles
      :AndIf 1∊modmask←changedmod≠items[I_FMOD;changedinx]  ⍝ file modification timestamp has changed
      :AndIf 1∊modmask←modmask∧(¯9.1≠items[I_NC;changedinx])∨(~changedfiles∊newdirs)  ⍝ ignore change of timestamps for dirs that remain dirs
          changednames←##.Notify¨{'changed'⍵}¨modmask/changedfiles
          ⍝ update data structure
          items[I_CHECK I_FMOD;modmask/changedinx]←↑((+/modmask)⍴⊂time)(modmask/changedmod)
      :EndIf
    ⍝⍝⍝ Look for creation/deletion of files (modification may be old in case unzipped)
      newnames←newnc←newmod←⍬
      :If ~0∊⍴newfiles
          newnames←##.Notify¨{'created'⍵}¨newfiles
          newnc←##.U.NameClass ##.U.OnEach newnames
          newmod←EncodeTS↑3 ⎕NINFO newfiles  ⍝ ⎕OPT could avoid doing it on dirs
      :EndIf
      :If ~0∊⍴delfiles
          delnames←##.Notify¨{'deleted'⍵}¨⌽delfiles  ⍝ delete directories last
      :EndIf
      ⍝ update data structures
      items←((~oldfiles∊delfiles)/items),↑newfiles newnames newnc((≢newfiles)⍴time)newmod
    ⍝⍝⍝ Look for content difference between APL and files
    ⍝ assume that if file modification timestamp hasn't changed,
    ⍝ then in case of difference the APL side is the "new" one.
      time←TS
      differ←notchecked←⍬
      :If ~0∊⍴items  ⍝ otherwise  items[I_CHECK;]  may have nested prototype
      :AndIf ~0∊⍴notchecked←⍸items[I_CHECK;]<start  ⍝ items not checked so far
          aplsrc←# ##.U.GetAplSource¨aplnames←items[I_NAME;notchecked]
          filesrc←##.U.GetFileSource¨filenames←items[I_FILE;notchecked]
      :AndIf ~0∊⍴differ←(mask←aplsrc≢¨filesrc)/notchecked  ⍝ items that differ from file definition
          (mask/aplnames){0 LogCrawler'Changed APL item: '⍺' → '⍵}¨(mask/filenames)
          (mask/aplsrc)##.U.Into¨(mask/filenames)
          mod←EncodeTS↑3 ⎕NINFO(mask/filenames)
          ⍝ update datastructure
          items[;differ]←↑(mask/filenames)(mask/aplnames)(##.U.NameClass¨mask/aplnames)((+/mask)⍴time)mod
      :EndIf
    ⍝⍝⍝ Update global data structure
      LINKS[;inx]←link items time active
      ⍝##.U.Log'Items: ',(⍕⊃⌽⍴items),' ⋄ Source compared: ',(⍕≢notchecked),' ⋄ Differ: ',(⍕≢differ)
    ∇



:EndNamespace
