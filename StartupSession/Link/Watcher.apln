:Namespace Watcher
    ⎕IO ⎕ML←1 1
    ⎕CT←0  ⍝ to compare EncodeTS

    DYALOGVERSION←1 .1+.×2↑⊃(//)'.'⎕VFI 2⊃'.'⎕WG'AplVersion'  ⍝ required at ⎕FIX time - can't rely on ##.U
    IS180←18≤DYALOGVERSION
    IS181←18.1≤DYALOGVERSION

    CRAWLER←0                               ⍝ allow using crawler


    ⍝⍝⍝⍝⍝ .Net System.IO.FileSystemWatcher ⍝⍝⍝⍝⍝

    USE_NQ←0                                ⍝ Set to 1 to enqueue calls to Notify via a Timer objecy
    FSWQ←'⎕SE.Link.Watcher.QUEUE'           ⍝ FSW Queue Object name prefix

    TimerEvent←140
    NotifyEvent←7777
    CloseEvent←7778
    Timeout←5000       ⍝ Length of timeout waiting for WatcherThread actions

    ∇ (dotnet dotnetcore)←HasDotNet;⎕USING
    ⍝ FileSystemWatcher usable only with v18.0 and later
      :If ~IS180    ⍝ Executed at ⎕FIX time, so can't rely on ##.U
          dotnet←dotnetcore←0
      :Else
    ⍝ Assumptions :
    ⍝ Dyalog only allows .Net Framework v4 (v1 v2 and v3.x are not supported anymore)
    ⍝ Therefore v3 and v5 must mean .Net Core
          :Trap 0 ⍝ ⎕USING← has been known to fail
              ⎕USING←''        ⍝ Ensure that System is present if at all possible
              dotnetcore←4≠System.Environment.Version.Major
              ⎕USING←',System',(~dotnetcore)/'.dll'
              dotnet←9.6=⎕NC⊂'System.IO.FileSystemWatcher'
          :Else
              dotnet←dotnetcore←0
          :EndTrap
      :EndIf
    ∇
    (DOTNET DOTNETCORE)←HasDotNet ⍝ cache result
    ∇ canwatch←CanWatch         ⍝ FileSystemWatcher or Crawler
      canwatch←CRAWLER∨DOTNET   ⍝ must be evaluated at runtime to allow ⎕SE.Link.Test to change them
    ∇


    ∇ RequeuedEvent args
     ⍝ Process events redirected via the timer
      :Select 2⊃args
      :Case TimerEvent  ⍝ Timer; do nothing for now
      :Case NotifyEvent ⍝ Re-queued Notify event
          ##.Notify&3⊃args
      :Case CloseEvent  ⍝ We have been asked to go away
          ⎕EX 1⊃args    ⍝ Erase the QUEUE object; WatcherThread will exit from DQ and the :Disposable control structure
      :EndSelect
    ∇

    ∇ WatchEvent(obj args);ct;nargs;timers
     ⍝ Callback for System.IO.FileSystemWatcher instance
     ⍝ Passes info on to ⎕SE.Link.Notify for processing
      {}2501⌶0 ⍝ Reap the thread on exit - triggers mantis 17628
      ⍝{}2502⌶0  ⍝ Discard parked thread - workaround mantis 17628
      nargs←⊂##.U.LCase⍕args.ChangeType
      nargs,←⊂args.FullPath
      :If 0≠⎕NC⊂'args.OldFullPath'
          nargs,←⊂args.OldFullPath
      :EndIf
      :If USE_NQ ⍝ Minimise time in .NET callback, enqueue Notify work for later
         ⍝ Do not split the following line into several lines: thread switch must NOT happen
          :If 0≠≢timers←'Timer'⎕WN ⎕SE.Link.Watcher ⋄ ⎕NQ(⊃timers)NotifyEvent nargs ⋄ :EndIf
      :Else      ⍝ Make direct calls to Notify
          ##.Notify&nargs
      :EndIf
    ∇

    ∇ WatchError(obj args);link;msg
      :Hold '⎕SE.Link.Links'
          :If 0∊⍴link←##.U.LookupFile obj.Path
              ##.U.Warn'FileSystemWatcher error on non-linked directory: ',obj.Path
          :Else
              0 Pause link
              msg←⊂'FileSystemWatcher error on linked directory: ',link.dir,' - Link has been paused. To recover, do:'
              msg,←⊂'      ]Link.Refresh ',link.ns,' -source=dir'
              ##.U.Warn 1↓##.U.FmtLines msg
          :EndIf
      :EndHold
    ∇

    ∇ WatcherThread args;q;watcher
     ⍝ Run a thread which creates a FileSystemWatcher object
     ⍝ ... makes sure there is a ⎕DQ to allow processing of events
     ⍝ ... and ensures it is disposed of
      :Disposable watcher←MakeWatcher args
          (q←FSWQ,⍕⎕TID)⎕WC'Timer'('Event'(TimerEvent NotifyEvent CloseEvent)'RequeuedEvent')('Interval' 1000)('Data'watcher)
          ⍝ 'Data' for testing purposes.
          watcher.EnableRaisingEvents←1
          ⎕DQ q ⍝ Wait here; q will be ⎕EX'd by Link.Break
          watcher.EnableRaisingEvents←0
          ⎕DL 1 ⍝ Wait for events to stop
      :EndDisposable
    ∇

    ∇ watcher←MakeWatcher args;⎕USING
     ⍝ Return a FileSystemWatcher object
     ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
      ⎕USING←',System',(~DOTNETCORE)/'.dll'
      watcher←⎕NEW System.IO.FileSystemWatcher
      watcher.(Path Filter)←args
      watcher.(onChanged onCreated onDeleted onRenamed)←⊂'WatchEvent'
      watcher.onError←'WatchError'
      watcher.IncludeSubdirectories←1
    ∇




   ⍝⍝⍝⍝⍝ MAIN API ⍝⍝⍝⍝⍝⍝⍝⍝

    ∇ Watch link;args;end;q;r;tid;z
    ⍝ Set up a file system watcher, return object that will be stored as "fsw" in ⎕SE.Link.Links[i]
      :If DOTNET
          args←link.dir(,'*')
          :If USE_NQ ⍝ enqueue Notify work for later: Return NS containing QUEUE name and TID of ⎕DQ'ing thread
              z←{0::0 ⋄ 2503⌶⍵}2 ⍝ Children of this thread should not take interrupts
              q←FSWQ,⍕tid←WatcherThread&args
              z←{0::0 ⋄ 2503⌶⍵}z ⍝ Restore thread interruption setting
              end←Timeout+3⊃⎕AI
              :While 0=⎕NC q ⋄ ⎕DL 0.05 ⋄ :EndWhile    ⍝ Wait for thread to create the Timer object
              (r←⎕NS'').(QUEUE TID)←q tid ⍝ Return name of QUEUE object and TID ⎕NQ'ing it
          :Else ⍝ Make direct calls to Notify: return the FSW object
              r←MakeWatcher args
              r.EnableRaisingEvents←1
          :EndIf
          link.fsw←r
      :ElseIf CRAWLER
          AddCrawler link
      :Else
          ##.U.Error'Cannot watch files'
      :EndIf
    ∇

    ∇ watch Pause link;fsw;link
    ⍝ pause/resume file watching
      :If 9=⎕NC'link.fsw.QUEUE'
          fsw←(⍕link.fsw.QUEUE)⎕WG'Data'
      :ElseIf 9=⎕NC'link.fsw'
          fsw←link.fsw
      :EndIf
      :If 0≠⎕NC'fsw'
          fsw.EnableRaisingEvents←watch
      :ElseIf CRAWLER
          watch PauseCrawler link  ⍝ can't hurt if non-crawled link
      :EndIf
    ∇
    ∇ paused←Paused link;fsw
    ⍝ report whether file watching is paused
      :If 9=⎕NC'link.fsw.QUEUE'
          fsw←(⍕link.fsw.QUEUE)⎕WG'Data'
      :ElseIf 9=⎕NC'link.fsw'
          fsw←link.fsw
      :EndIf
      :If 0≠⎕NC'fsw'
          paused←~fsw.EnableRaisingEvents
      :ElseIf CRAWLER
          paused←~IsCrawlerActive link
      :EndIf
    ∇

    ∇ Break links;end;tids;timer;timers
    ⍝ Cleanly shut down a file system watcher
    ⍝ Called by ⎕SE.Link.Break
      :If CRAWLER ⋄ RemoveCrawler links ⋄ :EndIf  ⍝ can't hurt of empty links or non-crawled links
      :If ~0∊⍴links
      :AndIf ~0∊⍴links←(9=⌊links.⎕NC⊂⊂'fsw')/links  ⍝ links that have a FSW
          :If USE_NQ ⍝ Did we using indirection via a queue?
              (timers tids)←↓⍉↑links.fsw.(QUEUE TID)
              :If ~0∊⍴timers←(9=⌊⎕NC timers)/timers
                  ⎕NQ¨timers{⍺ ⍵}¨CloseEvent  ⍝ tell timers to go away
              :EndIf
              end←Timeout+3⊃⎕AI
              :While ∨/tids∊⎕TNUMS     ⍝ Wait for thread to create the Timer object
                  ⍝:If end<3⊃⎕AI
                  ⍝    ¯1 ##.U.Warn'WatcherThread ',(⍕⎕TNUMS∩tids),' did not die on request'
                  ⍝:EndIf
                  ⎕DL 0.1
              :EndWhile
              ⎕EX links.fsw.QUEUE
          :Else ⍝ fsw should be a real FSW object
              ⍝ pitfall: must not call Dispose while processing a callback, otherwise the interpreter freezes
              {0::_←0 ⋄ ⍵.EnableRaisingEvents←0}¨links.fsw  ⍝ at )CLEAR time, .Net object might throw EXCEPTION: Object reference not set to an instance of an object.
              ⎕DL 0.1 ⍝ Give any extant events time to be processed
              {0::_←0 ⋄ _←⍵⍎'Dispose ⋄ 0'}¨links.fsw  ⍝ at )CLEAR time, .Net object might throw EXCEPTION: Object reference not set to an instance of an object.
          :EndIf
          links.fsw←⊂⍬
      :EndIf
    ∇












    ⍝⍝⍝⍝⍝ Crawler ⍝⍝⍝⍝⍝
    ⍝ Crawls BOTH the namespace and the directory
    ⍝ Will always fully crawl when interpreter comes back to descalc

    ⍝ Issues :
    ⍝ - Crawl should be allowed to fail once (race condition) before timer is de-activated (on second failure in a row)
    ⍝ - Comparing source is slow
    ⍝ - Looking for files with 5174⌶ is slow
    ⍝ - To compare sources, APL must NOT be tied to files
    ⍝ - Do a single ⎕NINFO to get timestamps too
    ⍝ - Synchronising the ⎕NINFO with the ⎕NGET

    LOGCRAWLER←1  ⍝ Log crawler-specific internals - undesirable unless debugging the crawler itself

    ∇ time←EncodeTS TS        ⍝ time in seconds
      time←0.001×0 12 31 24 60 60 1000⊥⍉↑⊆TS  ⍝ takes about 14 digits - ⎕CT must be zero
    ∇
    TS_OLD←EncodeTS 0  ⍝ old timestamp
    ∇ ts←TS  ⍝ Time stamp in seconds
      ts←EncodeTS ⎕TS
    ∇

    LINKS←4 0⍴⍬  ⍝ [link items check active;]
    L_LINK L_ITEMS L_CHECK L_ACTIVE←⍳4
    NO_ITEMS←5 0⍴⍬  ⍝ [file name nc check filemod;]
    I_FILE I_NAME I_NC I_CHECK I_FMOD←⍳5
    LASTSTART←LASTEND←TS_OLD

    INTERVAL←2⊣.1    ⍝ Timer interval in seconds
    GRANULARITY←.02  ⍝ Time granularity in seconds
    ∇ timer←CreateTimer;args
    ⍝ create Timer in thread 0, so that timer events will be generated when thread 0 comes back to six-space prompt
      :If 0≠⎕TID ⋄ (⎕←'⎕SE.Link.Watcher namespace must be fixed in thread 0')⎕SIGNAL 999 ⋄ :EndIf
      args←('Active' 0)('Interval'(⌈1000×INTERVAL))('Event'('onTimer' 'CrawlerEvent'))
      :If IS181 ⋄ args,←⊂('FireOnce' 1) ⋄ :EndIf
      timer←⎕NEW'Timer'args
    ∇
    TIMER←CreateTimer
    ⍝ There is one message queue per thread for APL events/callbacks
    ⍝ Objects will only see the message queue of the thread that created it (by calling ⎕NEW, ⎕WC, etc.)
    ⍝ When the thread is destroyed ;
    ⍝ - we don't know whether it (hands the queue to the parent thread) or (destroys the queue)
    ⍝ - future events will be passed to the parent thread
    ⍝ The message queue is processed :
    ⍝ - When the thread reaches descalc (size space prompt) (there can only be one thread in descalc at any given time)
    ⍝    (unless there is a ⎕DQ on the stack, so while we are tracing)
    ⍝ - its thread is running ⎕DQ


    ∇ warn LogCrawler msg;title
    ⍝ Use 1 to warn, 0 to log link-specific events, ¯1 to log crawler-specific events
      title←'⎕SE.Link.Crawler'
      :If (warn=1) ⋄ title ##.U.Warn msg
      :ElseIf (warn=0)∨(LOGCRAWLER∧warn=¯1) ⋄ title ##.U.Log msg
      :EndIf
    ∇

    ∇ AddCrawler link;args
      :Hold '⎕SE.Link.Crawler'
          ¯1 LogCrawler'Adding link: 'link' to ',LINKS[L_LINK;]
          LINKS,←link NO_ITEMS TS_OLD 1
          Crawl link  ⍝ set up
          :If ~TIMER.Active
              TIMER.Interval←⌈1000×INTERVAL  ⍝ for ⎕SE.Link.Test to change it
              TIMER.Active←1
              ¯1 LogCrawler'Started timer'
          :EndIf
      :EndHold
    ∇
    ∇ active PauseCrawler links;inx;mask
      :Hold '⎕SE.Link.Crawler'
          mask←LINKS[L_LINK;]∊links
          LINKS[L_ACTIVE;⍸mask]←mask/active
      :EndHold
    ∇
    ∇ active←IsCrawlerActive links;mask
      :Hold '⎕SE.Link.Crawler'
          mask←LINKS[;L_LINK]∊links
          active←mask\LINKS[L_ACTIVE;⍸mask]
      :EndHold
    ∇
    ∇ RemoveCrawler links;msg
      :Hold '⎕SE.Link.Crawler'
          LINKS/⍨←~LINKS[L_LINK;]∊links
          ¯1 LogCrawler(⊂'Removing link: '),links,(⊂' - Remaining links: '),(LINKS[L_LINK;])
          :If 0∊⍴LINKS
              TIMER.Active←0
              ¯1 LogCrawler'Stopping timer'
          :EndIf
      :EndHold
    ∇



    ∇ {msg}←CrawlerEvent msg;mask;ok;start
      :If ##.U.debug=2
          (1+⊃⎕LC)⎕STOP⊃⎕SI
      :EndIf
      :Trap ##.DEBUG↓0
          start←TS
          :If ~IS181  ⍝ v18.1 has FireOnce property so events never pile up
          :AndIf (INTERVAL-GRANULARITY)>(TS-LASTSTART)  ⍝ prevent running several events in a row when the queue has piled up
              ¯1 LogCrawler'Timer event: Event queue overloaded'
              :Return
          :ElseIf (0.5×INTERVAL)>(TS-LASTEND)  ⍝ prevent spending more than half the time crawling
              ¯1 LogCrawler'Timer event: Crawler overloaded'
          :EndIf
          ¯1 LogCrawler'Timer event'
          :Hold '⎕SE.Link.Crawler' '⎕SE.Link.Notify'
          ⍝ Crawl must call Notify directly for the :Hold to work !
              :If 1∊mask←LINKS[L_ACTIVE;]
                  Crawl¨mask/LINKS[L_LINK;]
              :EndIf
          :EndHold
          :If IS181  ⍝ v18.1 has FireOnce property so set it up again
              (⊃msg).FireOnce←1  ⍝ fire once more
          :EndIf
          LASTSTART←start
          LASTEND←TS
      :Else
          (⊃msg).Active←0
          ⎕←'Link: Crawler callback internal error - Crawler stopped'
      :EndTrap
    ∇

    ∇ {start}←Crawl link;active;allfiles;aplnames;aplsrc;changed;changedfiles;changedinx;changedmod;changednames;changednc;changedsrc;check;creations;deletions;delfiles;delmask;delnames;differ;dirs;filelist;filemod;filenames;filesrc;inx;items;mask;mewmod;mod;modmask;new;newfiles;newmod;newnames;newnc;newsrc;notchecked;ns;nsref;oldfiles;oldnames;src;start;time
      start←TS
      :If (⊃⌽⍴LINKS)<inx←LINKS[L_LINK;]⍳link
          1 LogCrawler'Link not crawled: '(,⍕link)  ⍝ should not happen
          :Return
      :EndIf
      (link items check active)←LINKS[;inx]
      :If ~active  ⍝ should not happen
          1 LogCrawler'Link not active: '(,⍕link)
      :EndIf
    ⍝⍝⍝ Look for creation/deletion of APL names
      time←TS
      nsref←⍎ns←link.ns
      newnames←1 ##.U.ListNs ns
      oldnames←items[I_NAME;]
      ⍝ check for creations
      newnc←newfiles←newmod←⍬
      :If ~0∊⍴creations←newnames~oldnames
          newsrc←nsref ##.U.GetAplSource¨creations
          :If {1=≡⍵}¨newsrc
              ∘∘∘
          :EndIf
          newnc←nsref ##.U.NameClass¨creations
          newfiles←⊃link(1 ##.U.DetermineFileName)((≢creations)⍴⊂ns)((1+≢ns)↓¨creations)((≢creations)⍴⊂'')newnc
          creations{0 LogCrawler'Created APL item: '⍺' → '⍵}¨newfiles
          newsrc ##.U.Into¨newfiles
          newmod←EncodeTS↑3 ⎕NINFO newfiles
      :EndIf
      ⍝ check for deletions
      oldfiles←⍬
      deletions←oldnames~newnames,⊂''  ⍝ files that don't have a proper name (oldname≡'') don't contribute to APL deletions !
      :If 1∊delmask←oldnames∊deletions
          oldfiles←⊃link(1 ##.U.DetermineFileName)((+/delmask)⍴⊂ns)((1+≢ns)↓¨delmask/oldnames)((+/delmask)⍴⊂'')(delmask/items[I_NC;])
          allfiles←4⊃¨5177⌶⍬
          :If 1∊mask←oldfiles∊allfiles  ⍝oldfiles∩allfiles  ⍝ some oldfiles still tied - should not happen
              (mask/delmask/oldnames){1 LogCrawler'Deleted APL item: file still in use: '⍺' → '⍵}¨(mask/oldfiles)
          :EndIf
          :If 1∊mask←~mask  ⍝~0∊⍴lostfiles←oldfiles~allfiles  ⍝ delete oldfiles that are not tied to anything
              (mask/delmask/oldnames){0 LogCrawler'Deleted APL item: '⍺' → '⍵}¨(mask/oldfiles)
              3 ⎕NDELETE⌽(mask/oldfiles)  ⍝ delete directories last
          :EndIf
      :EndIf
      ⍝ update data structure
      items←((~delmask)/items),↑newfiles creations newnc((≢creations)⍴⊂time)newmod
    ⍝⍝⍝ Look for files (not dirs) with a change of modification timestamp
      time←TS
      (filelist dirs filemod)←link(1 ##.U.ListFiles)link.dir ⋄ filemod←EncodeTS↑filemod
      (filelist dirs filemod)/⍨←⊂~filelist∊⊂link.dir,'/'  ⍝ do not keep track of root
      (filelist filemod){⍺[⍵]}←⊂⍒dirs ⋄ dirs←(+/dirs)↑filelist ⍝ keep dirs first
      oldfiles←items[I_FILE;]
      delfiles←oldfiles~filelist
      new←~changed←filelist∊oldfiles
      :If ~0∊⍴changedfiles←changed/filelist
          changedmod←changed/filemod
          changedinx←oldfiles⍳changedfiles
      :AndIf 1∊modmask←changedmod≠¨items[I_FMOD;changedinx]  ⍝ file modification timestamp has changed
      :AndIf 1∊modmask←modmask∧(¯9.1≠items[I_NC;changedinx])∨(~changedfiles∊dirs)  ⍝ ignore change of timestamps for dirs that remain dirs
          changednames←##.Notify¨{'changed'⍵}¨modmask/changedfiles
          ⍝ update data structure
          items[I_CHECK I_FMOD;modmask/changedinx]←↑((+/modmask)⍴⊂time)(modmask/changedmod)
      :EndIf
    ⍝⍝⍝ Look for creation/deletion of files (modification may be old in case unzipped)
      newnames←newnc←newmod←⍬
      :If ~0∊⍴newfiles←new/filelist
          newmod←new/filemod
          newnames←##.Notify¨{'created'⍵}¨newfiles
          newnc←##.U.NameClass ##.U.OnEach newnames
      :EndIf
      :If ~0∊⍴delfiles
          delnames←##.Notify¨{'deleted'⍵}¨⌽delfiles  ⍝ delete directories last
      :EndIf
      ⍝ update data structures
      items←((~oldfiles∊delfiles)/items),↑newfiles newnames newnc((≢newfiles)⍴time)newmod
    ⍝⍝⍝ Look for content difference between APL and files
    ⍝ assume that if file modification timestamp hasn't changed,
    ⍝ then in case of difference the APL side is the "new" one.
      time←TS
      differ←notchecked←⍬
      :If ~0∊⍴items  ⍝ otherwise  items[I_CHECK;]  may have nested prototype
          mask←items[I_CHECK;]<start  ⍝ items not checked so far
          mask∧←0<≢¨items[I_NAME;]    ⍝ items that have a valid APL name
      :AndIf ~0∊⍴notchecked←⍸mask
          aplsrc←# ##.U.GetAplSource¨aplnames←items[I_NAME;notchecked]
          filesrc←##.U.GetFileSource¨filenames←items[I_FILE;notchecked]
      :AndIf ~0∊⍴differ←(mask←aplsrc≢¨filesrc)/notchecked  ⍝ items that differ from file definition
          :If ∨/∨/¨{1=≡⍵}¨¨aplsrc filesrc
              ∘∘∘
          :EndIf
          (mask/aplnames){0 LogCrawler'Changed APL item: '⍺' → '⍵}¨(mask/filenames)
          ⍝ PLEASE keep the following code on same line to avoid switching thread between the file write and the ⎕NINFO
          (mask/aplsrc)##.U.Into¨(mask/filenames) ⋄ mod←EncodeTS↑3 ⎕NINFO mask/filenames  
          ⍝ update datastructure
          items[;differ]←↑(mask/filenames)(mask/aplnames)(##.U.NameClass¨mask/aplnames)((+/mask)⍴time)mod
      :EndIf
    ⍝⍝⍝ Update global data structure
      LINKS[;inx]←link items time active
      ⍝##.U.Log'Items: ',(⍕⊃⌽⍴items),' ⋄ Source compared: ',(⍕≢notchecked),' ⋄ Differ: ',(⍕≢differ)
    ∇


:EndNamespace
