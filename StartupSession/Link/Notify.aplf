 {r}←Notify args;actname;affected;children;curactname;curfile;curname;curnc;curnsname;deleted;dir;expname;exppath;hidden;i;inFail;link;linked;msg;nc;nsname;nsref;oldexpname;oldfile;oldname;oldnc;oldnsname;oldnsref;oldpath;path;recur;regex;retry;startai;tie;type;warn;watch;z;⎕IO;expfile
⍝ Notify Link system that an external file has changed
⍝ Usually called by FileSystemWatcher

 startai←⎕AI
 :Select U.debug
 :Case 1 ⋄ ⍝ ⎕←'Notify'args  ⍝ no need for this - Notify calls U.Log a lot
 :Case 2 ⋄ (1+⊃⎕LC)⎕STOP⊃⎕SI ⍝ ⋄ ⎕←'Notify'args
 :EndSelect

 :Trap DEBUG↓0
     ⎕IO←1
     recur←{+/∧\⍵∊1↑⍵}⎕XSI ⍝ Number of times Notify called self
     :Hold '⎕SE.Link.Notify',(recur≠1)/⍕recur ⍝ Avoid deadlock due to recursion
         r←⍬⊤⍬
         (type path oldpath)←{⍵,(≢⍵)↓'' '' ''},⊆args
         (path oldpath)←0 U.NormFile¨path oldpath

         →END U.If 0∊⍴link←U.LookupFile path  ⍝ not linked => done
         link←⎕NS link ⋄ link.fastLoad←0  ⍝ fastLoad not observed at Notify time


         deleted←type≡'deleted'
         msg←'Notify: ',type,' ',path,': '
         :If DEBUG>0 ⋄ :AndIf type≡'renamed'
             msg←(¯2↓msg),'←',oldpath,': '
         :EndIf

         :If ~deleted
             retry←3 ⍝ occasionnaly, on ⎕NMOVE made by Notify, the watcher rename event will not have access to file
             :While 0≤retry←retry-1
                 :Trap 0
                     dir←1=1 ⎕NINFO path
                     hidden←∨/6 ⎕NINFO(¯1+≢U.Ancestry link.dir)↓U.Ancestry path
                     :Leave
                 :Else ⋄ ⎕DL 0.000001
                 :EndTrap
             :EndWhile
             :If retry<0 ⋄ →END⊣U.Log msg,'not accessible' ⋄ :EndIf
             :If hidden ⋄ →END⊣U.Log'hidden' ⋄ :EndIf
             :If dir⍱link U.HasExtn path  ⍝ must be directory or have correct extension
                 →END⊣U.Log msg,'file type not managed by link'
             :EndIf
         :EndIf

         ⍝ determine expected apl name from file name, and actual apl name from source
         (nsname expname actname nc)←link U.DetermineAplName path
         nsref←#(0 U.GetRefTo)nsname  ⍝ we know nsname is fully qualified

         ⍝ determine current name tied to file (if any)
         (curnsname curactname curnc)←U.CurrentAplName path
         :If deleted  ⍝ can't examine source file - rely on expected apl name
             :If ~curnc∊0 ¯1 ⋄ actname←curactname ⋄ nc←curnc     ⍝ interpreter remembers that name was linked to file
             :ElseIf ~0∊⍴nsref ⋄ nc←nsref U.NameClass actname←expname  ⍝ rely on expected apl name inferred from file name
             :Else ⋄ nc←¯1  ⍝ nsname is invalid - see U.DetermineAplName
             :EndIf ⋄ dir←nc=¯9
         :ElseIf 0∊⍴actname ⋄ actname←expname  ⍝ failed to fix source - nc is 0 - only beforeRead can save us
         :EndIf

         oldname←actname
         affected←nsname,'.',actname
         :If curnc=¯1 ⋄ curname←'' ⋄ :Else ⋄ curname←curnsname,'.',curactname ⋄ :EndIf

         :If ~deleted  ⍝ won't read a deleted file
         :AndIf 3=⎕NC link.beforeRead ⍝ user exit defined? - must run BEFORE we exit on invalid file contents
             :If ~(link⍎link.beforeRead)'beforeRead'link path affected ⍝ return 1 to continue else 0
                 →END⊣U.Log msg,'handled by user'
             :EndIf
         :EndIf

         :If 0=≢nsref ⋄ →END⊣U.Warn msg,'file does not reflect in a valid namespace'
         :ElseIf (nc=¯1) ⋄ →END⊣U.Warn msg,'invalid name defined by file: ',path
         :ElseIf (deleted∨~link.fastLoad)∧(nc=0)  ⍝ cannot trust nc returned by DetermineAplName when opts.fastLoad
             →END⊣U.Log msg,(1+deleted)⊃'invalid file contents' 'could not determine which object was linked to it'
         :EndIf

         ⍝ determine current file tied to name we plan to use
         expfile←U.Deslash⊃link(0 U.DetermineFileName)nsname actname oldname nc
         :If 0∊⍴curfile←0 U.NormFile nsref U.CurrentFileName actname ⍝ not tied by interpreter
         :AndIf 2 ¯9∊⍨⌊nc   ⍝ only arrays and tradnamespaces don't have ties
             curfile←(⎕NEXISTS expfile)/expfile    ⍝
         :EndIf

         :Select type

         :Case 'created'               ⍝ A new file
             ⍝:If 0≠≢z←nsref U.CurrentFileName actname  ⍝ Redefines existing object with a source file
             ⍝:AndIf ⎕NEXISTS z       ⍝ ... and that file exists
             :If 0≠⎕NC affected    ⍝ object already exists - avoid re-linking when file was copy/pasted
             :AndIf curfile≢path   ⍝ sometimes file writes produce a create event on the same file - let it run
             :AndIf 0<≢curfile     ⍝ otherwise it's a regular file creation
                 →END⊣U.Warn msg,'ignoring attempt to redefine ',affected,(0<≢curfile)/' which is linked to ',curfile
             :ElseIf ~curnc∊0 ¯1    ⍝ file already tied to another name
                 U.Untie curname
                 U.Log msg,'creating ',affected,' - unlinking previously linked ',curname
             :Else
                 U.Log msg,'creating ',affected
             :EndIf

         :Case 'changed'               ⍝ Update to existing file?
             :If dir ⋄ →END⊣U.Log msg,'ignoring change to directory' ⋄ :EndIf
             :If path≡curfile      ⍝ name already tied to the same file
                 ⍝ Checking hash is not worth, compared to fixing file.... also it might have false positive on character inversion (multiple of 4-bytes apart)
                 ⍝ also, forcefilename might still want to rename the file
                 ⍝:If (nsref U.CurrentHash actname)≡(U.FileHash path) ⋄ →END⊣U.Log msg,'checksum unchanged - not updating ',affected ⋄ :EndIf
                 :If (0<≢curname)∧(curname≢affected) ⋄ ⎕EX curname ⋄ :EndIf   ⍝ name changed
                 U.Log msg,'updating previously linked ',affected,((0<≢curname)∧(curname≢affected))/' deleting previously defined ',curname
             :ElseIf (0≠⎕NC affected)∧(0≠≢curfile)      ⍝ name was tied to a different file
                 →END⊣U.Warn msg,'ignoring attempt to redefine ',affected,' which is linked to ',curfile
             :ElseIf ~curnc∊0 ¯1     ⍝ file already tied to a name
                 ⎕EX curname  ⍝ delete name in case the name defined by source has changed
                 U.Log msg,'updating un-linked ',affected,', expunging previously linked ',curname
             :Else
                 U.Log msg,'updating un-linked ',affected
             :EndIf

         :Case 'renamed'
             :If path≡curfile       ⍝ name already tied to the same file - happens when forceFilenames/forceExtensions moves back a file to where it was
                 ⍝:If (nsref U.CurrentHash actname)≡(U.FileHash path) ⋄ →END⊣U.Log msg,'checksum unchanged - not updating ',affected ⋄ :EndIf
                 U.Log msg,'updating previously linked ',affected
             :ElseIf 0≠⎕NC affected  ⍝ redefining existing name
             :AndIf curfile≢oldpath  ⍝ name not bound to old file (TODO won't work for arrays)
                 →END⊣U.Warn msg,'ignoring attempt to redefine ',affected,(0<≢curfile)/' which is linked to ',curfile
             :EndIf
             (oldnsname oldexpname)←2↑link U.DetermineAplName oldpath  ⍝ cannot determine actual name and nameclass because file is gone
             oldname←oldnsname,'.',oldexpname
             :If 9=⎕NC oldnsname
                 oldnsref←(⍎oldnsname) ⋄ oldnc←oldnsref.⎕NC oldexpname
                 oldfile←oldnsref U.CurrentFileName oldexpname
             :Else ⋄ oldnsref←⎕NULL ⋄ oldnc←¯1 ⋄ oldfile←''
             :EndIf
             :If dir         ⍝ move traditional ns
                 :If 9=⌊oldnc ⍝ old name is an existing namespace
                     ⍝actname nsref.⎕NS oldnsref.⍎oldexpname ⍝ deep copy into parent with a nice name
                     actname nsref.⎕NS''  ⍝ create empty namespace
                     oldnsref.⎕EX oldexpname                        ⍝ expunge old
                     :Trap 0 ⋄ children←⊃⎕NINFO⍠1⊢path,'/*'
                     :Else ⋄ children←0⍴⊂''
                     :EndTrap
                     U.Log msg,'namespace rename ',oldname,' → ',affected
                     Notify¨{'changed'⍵}¨children
                 :Else                                    ⍝ no old ns
                     U.Warn msg,'not found namespace ',oldname,' - loading ',affected,' from ',path
                     :If 0<≢inFail←link U.FixFiles nsref path
                         U.Warn msg,'failed to load: ',⍕inFail
                     :EndIf
                 :EndIf
                 →END
             :EndIf
             :If ~oldnc∊0 ¯1    ⍝ old apl name must be expunged
                 oldnsref.⎕EX oldexpname
             :EndIf
             :If ~curnc∊0 ¯1     ⍝ new file already tied to a name
                 U.Untie curname
                 U.Warn msg,'moving ',oldname,' to ',affected,' - unlinking previously linked ',curname
             :Else
                 U.Log msg,'moving ',oldname,' to ',affected
             :EndIf

         :Case 'deleted'
             :If 0=⎕NC affected  ⍝ object didn't exist
                 U.Log msg,'not found: ',affected
             :ElseIf (0<≢curfile)∧(path≢curfile)  ⍝ name tied to another file - don't expunge
                 →END⊣U.Log msg,'not expunging ',affected,' linked to ',curfile
             :ElseIf (~curnc∊0 ¯1)∧(curname≢affected)     ⍝ a different file was tied to a name
                 U.Untie curname
                 U.Warn msg,'expunging ',affected,' - unlinking previously linked ',curname
             :Else
                 U.Log msg,'expunging ',affected
             :EndIf
             ⎕EX affected
             →END

         :Else
             U.Log msg,'Unhandled event type'
             →END ⍝ might as well give up now

         :EndSelect

         ⍝ rename files if incorrectly named
         watch←'dir' 'both'∊⍨⊂link.watch  ⍝ watching files
         :If link.fastLoad<(link.forceFilenames∨link.forceExtensions) ⍝ fastLoad is disabled in Notify
         :AndIf path≢exppath←expfile(link.forceFilenames U.MergeFileName link.forceExtensions)path
             :If ⎕NEXISTS exppath  ⍝ would clash with existing file - do not dare fixing
                 →END⊣U.Warn msg,'name clash - cannot move file to existing ',exppath,' - cannot fix ',affected
             :Else
                 U.Log msg,'moving to ',exppath
                 exppath ⎕NMOVE path ⋄ path←exppath
                 ⍝ If we do the line below, then occasionally the watcher fails to callback on move, making the new file definition not fixed
                 ⍝→END U.If watch     ⍝ file watcher will take care of the rest
                 :While ~⎕NEXISTS exppath ⋄ ⎕DL 0.000001 ⋄ :EndWhile    ⍝ ensure file effectively moved before fixing
             :EndIf
         :EndIf

         ⍝ fix file
         tie←'both' 'ns'∊⍨⊂link.watch ⍝ tie to file if watching namespace
         :If dir  ⍝ create namespace - optimisation to avoid the call to ⎕NINFO that QFix would cause through GetFileSource
             actname nsref.⎕NS''
         :ElseIf ~nsref U.QFix path actname tie
             U.Warn msg,'Unable to fix file'
         :EndIf

END:
         ⍝:If U.debug≠0 ⋄ ⎕←'Notify time spent: ',⍕⎕AI[3]-startai[3] ⋄ :EndIf
     :EndHold ⍝ 'Notify'
 :Else
     U.Resignal 1
 :EndTrap
