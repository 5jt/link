:Namespace U ⍝ Utilities
    ⎕IO←⎕ML←1

    :Section Constants
    isWindows←'Win'≡3↑⊃# ⎕WG'APLVersion'
    ∇ (canwatch dotnetcore)←_CanWatch;⎕USING
    ⍝ Assumptions :
    ⍝ Dyalog only allows .Net Framework v4 (v1 v2 and v3 are not supported anymore)
    ⍝ Therefore v3 and v5 must mean .Net Core
      :Trap 0 ⍝ ⎕USING← has been known to fail
          ⎕USING←''        ⍝ Ensure that System is present if at all possible
          dotnetcore←4≠System.Environment.Version.Major
          ⎕USING←',System',(~dotnetcore)/'.dll'
          canwatch←9.6=⎕NC⊂'System.IO.FileSystemWatcher'
      :Else
          canwatch←dotnetcore←0
      :EndTrap
    ∇
    (CanWatch DotNetCore)←_CanWatch ⍝ cache result
    ⍝ constants with defaults
    ∇ d←debug
      :If 0=⎕NC'##.DEBUG' ⋄ d←##.DEBUG←0
      :Else ⋄ d←##.DEBUG
      :EndIf
    ∇

    :EndSection


    :Section APL covers
      OnEach←{ ⍝ ¨ without prototype call on empty
          0∊⍴⍵:⍵   ⍝ if empty return empty
          ⍺←⊢      ⍝ ambivalent
          1:_←⍺ ⍺⍺¨⍵   ⍝ shy call
      }
    :EndSection


    :Section Stack Frames      ⍝ Tacit necessary to avoid them
    Resignal←⎕SIGNAL{⍺←'' ⋄ ⍵/⊂⎕DMX.(('EN'(EN+11×EN=0))('EM' EM)('Message'(Message,⍺)))}
        Check←{⍺←0⋄⍺}⍴⍨¯1∊∘⎕NC⊢⊆⍨'/'≠⊢ ⍝ leave early if any bad name
    If←⍴⍨
    ERRNO←99              ⍝ official API error number
    ∇ {errno}Error msg;caller
      :If 900⌶⍬ ⋄ errno←ERRNO ⋄ :EndIf
      caller←(1++/⎕SE.Link IsParent¨⎕RSI)⊃⎕XSI  ⍝ outer caller from ⎕SE.Link
      (caller,': ',msg)⎕SIGNAL errno
    ∇
    :EndSection



    :Section Strings
    Shortest←{⍵⊃⍨{⍵⍳⌊/⍵}≢¨⍵}                ⍝ Shortest string in list
    Case←{⍺(819⌶)¨⍵}                        ⍝ Upper/Lower case
    LCase←{819⌶⍵}                           ⍝ Lower case
    ⍝Join←{(⍕⍺),⍺⍺,(⍕⍵)}                     ⍝ Join ⍺ and ⍵ using ⍺⍺
    JoinList←{⊃,/1↓,(⊂⍺⍺),[1.5],⍵}          ⍝ Join list of items with ⍺⍺
    JoinEach←{,/⍺,⍺⍺,[1.5]⍵}                ⍝ Join¨
    Slash←∊∘'/\'                            ⍝ Mark slashes
    Parts←{⍵⊆⍨~Slash ⍵}                     ⍝ Path parts
    TilLast←{⍵↓⍨-⍺⍳⍨⌽⍵}
    Path←'/'∘TilLast                        ⍝ Until last slash
    Parent←'.'∘TilLast                      ⍝ Until last dot
    PadThis←{⍵,'⎕THIS'/⍨0=≢⍵}               ⍝ Default path to here
    NsExpr←{'''',⍵,'''⎕NS⍬'}                ⍝ Expression to create namespace
    Begins←{⊃⍺⍷⍵}                           ⍝ ⍵ starts with ⍺
    WinSlash←'\'@Slash⍣isWindows            ⍝ force windows slashes only on windows machines
    DotSlash←'.'@Slash                      ⍝ Convert dots to slashes
        Combine←{(⍕⍺),⍨(326≠⎕DR ⍺)/'.',⍨⍕⍵}/
    List←{∊{' ',⍕⍵}¨⍵}
      Arrow←{                               ⍝ appropriate symbol to show ns-dir connection
          lr←'←→'/⍨2 2⊤'ns' 'dir' 'both'⍳⊂⍵.watch
          ⍵.ns,' ',lr,' ',WinSlash ⍵.dir
      }
    HasNewlines←{∨/10 11 12 13 133 8232 8233∊⎕UCS ⍵}  ⍝ will confuse ⎕NGET/⎕NPUT and 2 ⎕FIX 'file://...'

    :EndSection


    :Section Covers for I-beams and other built-ins
    CurrentFileName←{4⊃⍺.(5179⌶)⍵}   ⍝ Return current file name tied to apl name ⍵ in namespace ⍺
    CurrentHash←{7⊃⍺.(5179⌶)⍵}       ⍝ Return current hash of tied file
    Where←{⍵⌿⍺}                      ⍝ Filter as function
    GetFileInfo←{5174⌶⍵}             ⍝ Return links to file
      GetFile←{
          11::⊃⎕NGET ⍵ 1                     ⍝ 17.0 Unicode
          ⊃⎕NGET⍠'ContentType' 'APLCode'⊢⍵ 1 ⍝ 17.1+ Classic
      }
      ⍝ Untie←{0=⎕NC'⍺':_←5178⌶⍵ ⋄ ⍺.(5178⌶)⍵}  ⍝ untie an apl name from its file - doesnt work because of mantis 18148
    ∇ {ok}←{ns}Untie name;nc
      :If 900⌶⍬ ⋄ ns←⊢ ⋄ :EndIf
      nc←2⊃ns Fix name(ns GetAplSource name) ⍝ refix from source because of mantis 18148
      ok←~nc∊0 ¯1
    ∇

    ∇ res←(Fn EachUnique)arg;inx;mask;unq
      unq←(mask←(inx←⍳⍨arg)=(⍳⍴arg))/arg
      res←(Fn¨unq)[(+\mask)[inx]]
    ∇
    ∇ (names parents scriptitems)←GetFileTiesIn rootns;all;allrefs;mask;parents;r;t;urefs
     ⍝ Find all file system links to objects below rootns
      allrefs←2⊃¨all←5177⌶⍬
      t←urefs←∪allrefs
      mask←(≢urefs)⍴0
      :If 0≠≢t ⋄ :Repeat
              mask∨←(⍕¨t)∊(⊂⍕rootns) ⍝ Have we reached rootns?  - ⍕ because of mantis 18147
              :If t≡t.## ⋄ :Leave ⋄ :EndIf  ⍝ continue until everything is root
              t←t.##         ⍝ Move all pointers up to parent
          :EndRepeat ⋄ :EndIf
      :If 0=≢r←(allrefs∊mask/urefs)/all ⍝ selection of 5177⌶⍬
          names←0⍴⊂'' ⋄ parents←0⍴# ⋄ scriptitems←⍬
      :Else
          names←⍕¨1⊃¨r
          parents←⍎¨⍕¨2⊃¨r ⍝ need ⍎¨⍕¨ because of mantis 18147
          scriptitems←IsScripted EachUnique parents  ⍝ parent is scripted → item is a script item
      :EndIf
    ∇
    ∇ r←RemoveFileTiesIn rootns;names;parents;scriptitems
     ⍝ Find all file system links to objects below rootns, and remove using 5178⌶
     ⍝ Return number of links broken
      (names parents scriptitems)←GetFileTiesIn rootns ⍝ links to be removed
      :If 0∊scriptitems
          r←+/((~scriptitems)/parents)Untie¨((~scriptitems)/names)
      :Else
          r←0
      :EndIf
      ⍝ there might be some orphaned script items - interpreter must forget about them
      :If 1∊scriptitems ⍝ links to be removed
          {}(scriptitems/parents){⍺.(5178⌶)⍵}¨(scriptitems/names)
      :EndIf
    ∇

    ∇ changed←FileHasChanged(ns name file filesrc);compsrc;file2;hash;line;lines;name2;nameref;nc;parent;ts
      compsrc←0 ⋄ changed←0
      (name2 parent nc file2 line lines hash ts)←ns.(5179⌶)name  ⍝ name2 may be a name or a ref - parent is a ref
      :If 0=ns NameClass name ⋄ changed←1  ⍝ name not defined - need to update from file
      :ElseIf 0∊⍴name2 ⋄ compsrc←1 ⍝ not tied at all - need to compare sources directly (arrays only)
      :ElseIf file≢file2 ⋄ changed←1  ⍝ not the same file
      :ElseIf hash≢2 ⎕NQ'.' 'GetBuildID'file ⋄ changed←1 ⍝ not the same hash - unfortunately, there could be a false negative with CRC32 - e.g. swap two bytes that are offset by 4 bytes : '⌈,⌊'→'⌊,⌈' or 'A,B,C'→'C,B,A'
      :EndIf
      :If compsrc ⋄ ⍝ need a closer look
          :If 0∊⍴filesrc ⋄ filesrc←GetFileSource file ⋄ :EndIf
          changed←filesrc≢ns GetAplSource name  ⍝ compare source to be sure - will return 1 where whitespace not preserved
      :EndIf
    ∇

    ∇ r←ViewMetaData mode
    ⍝ Experiemental function to inspect Link meta data.
    ⍝ For debugging only.
    ⍝ !!! DO NOT USE THIS function in application code!!!
      r←5177⌶⍬
      r←(~(8↑¨⍕¨2⊃¨r)∊⊂'⎕SE.Link')/r
      r←r[⍋⍕⌽↑2↑¨r]
     
      :Select mode
      :Case 'raw' ⋄ →0
      :Case 'count' ⋄ r←(⍕¨2⊃¨r){⍺(≢⍵)}⌸1⊃¨r
      :Case 'group' ⋄ r←(⍕¨2⊃¨r){⍺ ⍵}⌸1⊃¨r
      :CaseList '' 'report'
          r←↑4↑¨r
          r[;1]←(⍕¨r[;2]),¨'.',¨r[;1]
          r←r[;1 3 4]
      :Else
          'mode must be one of: raw count group report'⎕SIGNAL 11
      :EndSelect
    ∇

    :EndSection



    :Section Files

    ∇ path←Enslash path
      path,←'/'/⍨~'/\'∊⍨⊃⌽path ⍝ append trailing slash if missing
    ∇
    ∇ path←Deslash path
      path↓⍨←-+/∧\⌽path∊'/\'  ⍝ remove trailing slash
    ∇
    NormFile←{⍺<0=≢⍵:⍵ ⋄ ∊1⎕NPARTS ⍵}  ⍝ ⍺=1 : '' means current directory
    ∇ dir←trail NormDir dir
      dir←∊1 ⎕NPARTS dir            ⍝ normalise - '' means current dir
      :If trail ⋄ dir←Enslash dir
      :Else ⋄ dir←Deslash dir
      :EndIf
    ∇
    ∇ mask←opts HasExtn files;act;exp;regex
    ⍝ mask of files that have valid extensions
      exp←opts.(codeExtensions,customExtensions,⊢/typeExtensions) ⍝ all interesting extensions
      act←{1↓⊃⌽⎕NPARTS ⍵}¨,⊆files    ⍝ actual extensions
      ⍝ regex special characters : .$^{[(|)*+?\
      regex←'^' '$' '[\^\$]' '\*' '\?'⎕R'^' '$' '\\\0' '.*' '.'⊢exp ⍝ convert glob to regex
      mask←1@(⎕IO+regex ⎕S 2⊢act)⊢(⍴act)⍴0
      :If (1=≡,files)∨(0=⍴⍴files) ⋄ mask←⊃mask ⋄ :EndIf
    ∇

      Tail←{ ⍝ ⍺:typeExtensions; ⍵:nc
          ¯9.1=⍵:'/'    ⍝ unscripted namespace are given name class ¯9.1
          (types exts)←↓⍉⍺
          exts,←⊂'dyalog'
          exts,¨⍨←'.'
          exts⊃⍨⌊/types⍳⍵,⌊⍵
      }

      ApplyOldExtn←{ ⍝ Correct new extension to .dyalog if old source exists
          (dir name ext)←⎕NPARTS ⍵
          ext≡'.dyalog':⍵
          alt←dir,name,'.dyalog'
          (⎕NEXISTS alt)>(⎕NEXISTS ⍵):alt
          ⍵
      }

    SplitDir←{(~Slash ⍵)⊆⍵}
    Ancestry←{,\(1@1⊢Slash ⍵)⊂⍵}    ⍝ {((¯1+⍵⍳'/')↑⍵)∘,¨,\('/'=⍵)⊂⍵}   ⍝ ⍪⎕SE.Link.U.Ancestry¨ 'C:' '.' '',¨⊂'/a/bb/ccc'

    FileHash←{2 ⎕NQ #'GetBuildID' ⍵}

    IsDir←{0::0 ⋄ 1=1 ⎕NINFO ⍵}

      Into←{ ⍝ Put vtv ⍺ into file ⍵ - return success
          22::_←0                  ⍝ no file access
          _←3 ⎕MKDIR⊃1 ⎕NPARTS ⍵ ⍝ create dir if needed
          11::_←1⊣(⊂⍺)⎕NPUT⊢⍵ 1        ⍝ overwrite - Dyalog v17.0 Unicode
          1:_←1⊣(⊂⍺)⎕NPUT⍠'ContentType' 'APLCode'⊢⍵ 1        ⍝ overwrite - Dyalog v17.1+ Classic
      }

    ∇ name←CaseCodePart name;bin;digits;len;⎕IO
    ⍝ case-code a string
      ⎕IO←0
      →0 If 0=≢name  ⍝ empty name doesn't get case coded
      bin←name≠819⌶name
      len←⌈3÷⍨≢bin
      digits←2⊥⌽⍉⌽len 3⍴bin↑⍨3×len
      digits↓⍨←+/∧\0=digits
      name,←'-',⎕D[digits,0/⍨⍬≡digits]
    ∇
    ∇ name←StripCaseCodePart name;code;length;mask;⎕IO
    ⍝ strip case code from a string
      ⎕IO←0
      length←(⌽name)⍳'-'
      →0 If length∊0,≢name   ⍝ case code must be after hyphen
      code←⎕D⍳(-length)↑name
      name←((-length+1)↓name)
      →0 If code∨.>7         ⍝ case code must be octal digits
      →0 If(⌈3÷⍨≢name)≠(≢code)  ⍝ case code must be of correct length
      mask←⌽,⍉2 2 2⊤code     ⍝ boolean mask of upper-case
      →0 If~(⊂(≢name)↓mask)∊⍬(,0)(0 0)  ⍝ mask must be padded with 0-2 zeros
      name←((≢name)↑mask)Case name
    ∇
    ∇ name←(dir CaseCode flatten)name;ext;file;parts;path
    ⍝ case-code a file located under linked dir
      :If name≡dir ⋄ :Return ⋄ :EndIf  ⍝ would wrongfully cut name because of missing trailing slash
      (path file ext)←1 ⎕NPARTS name
      :If flatten  ⍝ case code file name only
          file←CaseCodePart file
          name←∊path file ext
      :Else  ⍝ case code sub-directories too
          path←(≢dir)↓path       ⍝ do not case-code linked directory
          parts←(Parts path),⊂file
          parts←CaseCodePart¨parts      ⍝ case-code each part of path independently
          name←'/'JoinList(⊂dir),parts
          name,←ext
      :EndIf
    ∇
    ∇ name←(dir StripCaseCode flatten)name;ext;file;parts;path
    ⍝ strip case code from a file name located under linked dir
      :If ~'-'∊(≢dir)↓name  ⍝ no casecode
      :OrIf name≡dir  ⍝ would wrongfully cut name because of missing trailing slash
          :Return
      :EndIf
      (path file ext)←1 ⎕NPARTS name
      :If flatten   ⍝ only file name is case coded
          file←StripCaseCodePart file
          name←∊path file ext
      :Else  ⍝ sub-directories are case-coded
          path←(≢dir)↓path       ⍝ do not case-code linked directory
          parts←(Parts path),⊂file
          parts←StripCaseCodePart¨parts      ⍝ case-code each part of path independently
          name←'/'JoinList(⊂dir),parts
          name,←ext
      :EndIf
    ∇

    ∇ order←GradeFiles files
    ⍝ slashes after all chars and quads before all
    ⍝ in "descending" order into folders: must process parent folders first
      order←⍋¯1@{9109=⍵}9999999@{47=⍵}↑⎕UCS¨files
    ∇
    ∇ {r}←to Relocate from;i;nextfrom;nextto
    ⍝ move list of files, updating file names as we go through the list
      r←⍬
      :While ~0∊⍴to
          (nextto nextfrom)←⊃¨(to from) ⋄ (to from)↓⍨←1
          :If nextto≢nextfrom
              r,←nextto ⎕NMOVE nextfrom
              from←(nextfrom ⎕R nextto)from  ⍝ update directories in particular
          :Else ⋄ r,←1   ⍝ no need to copy
          :EndIf
      :EndWhile
    ∇

    :EndSection





    :Section Namespaces

    ⍝ Supported name classes
    _NameClasses←2.1              ⍝ array
    _NameClasses,←3.1 3.2 4.1 4.2 ⍝ tradfn/dfn/tradop/dop
    _NameClasses,←9.1 9.4 9.5     ⍝ ns/class/interface
    NameClasses←{(~⍵)↓_NameClasses}  ⍝ 0=exclude arrays ⋄ 1=include arrays

      IsScripted←{
          0<≢# CurrentFileName ⍵:1          ⍝ tied namespaces are always scripted !!! tied scripted namespace where file is lost produce a pop up at ⎕SRC time !!!
          16::0
          1⊣⎕SRC ⍵
      }
        RootOf←{⍵.##}⍣≡
    IsRoot←{⍵=⍵.##}                         ⍝ is namespace a root
    SplitNs←{t←1+d←-'.'⍳⍨⌽⍵ ⋄ (d↓⍵)(t↑⍵)}   ⍝ '#.ns' 'name' ← SplitNs '#.ns.name'  - ⍵ must be fully qualified - where will be empty for roots
    IsParent←{p←⍵.## ⋄ ⍺∊p ⍵:1 ⋄ ⍵=p:0 ⋄ ⍺∇p }  ⍝ is ⍺ parent of ⍵

    Execute←{⍺←⎕DMX.⎕NS⍬ ⋄ ⍺⍎⍵}             ⍝ safe execute (avoid clash with our stuff) ⋄ missing ⍺ requires fully qualified name
    _IsRootName←∊∘('#') (,'#') ('⎕SE')('⎕DMX')
    ⍝_NAMECHAR←'#.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyzÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüþ∆⍙'
    ⍝_NAMECHAR,←⎕UCS (82≠⎕DR'')/(9397+⍳26)  ⍝ underscored alphabet for unicode
    _NAMECHAR←35 46 48 49 50 51 52 53 54 55 56 57 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 95 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 216 217 218 219 220 221 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 248 249 250 251 252 254 9398 9399 9400 9401 9402 9403 9404 9405 9406 9407 9408 9409 9410 9411 9412 9413 9414 9415 9416 9417 9418 9419 9420 9421 9422 9423 8710 9049  ⍝ full list of legal name members
    _NAMECHAR←⎕UCS ⎕AVU∩⍣(82=⎕DR'')⊢_NAMECHAR  ⍝ classic interpreter must pick from ⎕AVU
    _IsNameChar←∊∘_NAMECHAR
    ∇ ok←_IsAplName name;mask
    ⍝ avoid executing any string when trying to reference a namespace with ⍎
      :If ~ok←∧/mask←_IsNameChar name
          ⍝ allow ⎕SE and ⎕DMX in it
          ok←∧/mask←mask∨('⎕SE.'⍷name)∨('⎕DMX.'⍷name)
      :EndIf
    ∇
    ⍝IsRootName←{⍺←⊢ ⋄ _IsRootName ⊂⍵:1 ⋄ ~_IsAplName ⍵:0 ⋄ 0::0 ⋄ IsRoot ⍺ Execute ⍵}    ⍝ is name of a root
    IsRootName←{11::0 ⋄ 0∊⍴⍵:0 ⋄ (⊂⍵ ⍺.⎕WG'Type')∊'Root' 'Session'}  ⍝ ⍵ is a name, ⍺ is a namespace - ⎕WG will fail with DOMAIN ERROR on '⎕DMX' and invalid names, ''∘⎕WG does it in current space which is not what we want
    ∇ nc←{nsref}NameClass name
    ⍝ safe name class (avoid clash with our stuff)
    ⍝ return ¯9.1 for trad ns that map to directories and not files
      :If 900⌶⍬ ⋄ nsref←⎕DMX.⎕NS ⍬ ⋄ :EndIf
      name←('⎕THIS\.' '\.⎕THIS'⎕R'' '')name  ⍝ Mantis 18553 : '⎕THIS' not understood by ⎕NC nor ⎕NS nor ⎕WG
      :If name≡'⎕THIS' ⋄ nc←⎕NC⊂'nsref'
      :Else ⋄ nc←nsref.⎕NC⊂,name
      :EndIf
      :If 9.1=nc ⍝ that includes ⎕DMX
      :AndIf ~IsScripted nsref⍎name
          nc←¯9.1
      :ElseIf nc∊¯1 9.2  ⍝ roots may report ¯1 (⎕NC⊂,'#') or 9.2 (foo←# ⋄ ⎕NC⊂,'foo')
      :AndIf nsref IsRootName name
          nc←¯9.1
      :EndIf
    ∇

    ∇ n←UcmdStacks xsi
      n←xsi{(⍵∊⍺)×¯1+⍺⍳⍵}⊂'⎕SE.UCMD' ⍝ Drop UCMD stack if present
    ∇
    ∇ (container ns)←rsi_xsi ContainerNs ns;n;xsi;rsi
    ⍝ container is a reference, and namespace is fully qualified namespace name
      (rsi xsi)←rsi_xsi
      :If 9=⎕NC'ns'
          (container ns)←#(⍕ns)
      :Else
          container←⊃(UcmdStacks xsi)↓rsi
          ns←(⍕container),(0≠≢ns)/'.',ns  ⍝ can't use NormNs because ns may not exist
      :EndIf
    ∇

    ∇ r←{where}(create GetRefTo)ns;name;nc;parent
    ⍝ Get a reference to a container namespace (or ⍬ if that is not possible)
      :If 9=⎕NC'ns' ⋄ r←ns ⋄ :Return ⋄ :EndIf ⍝ already a ref
      r←⍬ ⋄ :If 900⌶⍬ ⋄ where←⎕DMX.⎕NS ⍬ ⋄ :EndIf
      ns←('⎕THIS\.' '\.⎕THIS'⎕R'' '')ns  ⍝ Mantis 18553 : '⎕THIS' not understood by ⎕NC nor ⎕NS nor ⎕WG
      :If ns≡'⎕THIS'
          :If ~900⌶⍬ ⋄ r←where ⋄ :EndIf  ⍝ can't have a ⎕THIS relative to nothing
          :Return
      :EndIf
      :If 9=⌊|nc←where NameClass ns      ⍝ is a fully qualified name
          r←⍎ns
      :ElseIf 0≠nc ⍝ Invalid or used name, not worth trying
      :ElseIf create  ⍝ doesn't exist yet - attempt to create it
          :Trap 0 ⋄ r←⍎ns where.⎕NS''  ⍝ create it
          :Else ⋄ r←⍬    ⍝ can't be created
          :EndTrap
      :EndIf
    ∇

    NormNs←{⍺←⊢ ⋄ ⍕⍺(0 GetRefTo)⍵}    ⍝ normalise a namespace name - can swallow a ref too

    ∇ refs←ListNamespaces ref;newrefs;next;prev
    ⍝ List unscripted namespaces under ref
      refs←prev←,ref
      :While ~0∊⍴next←{0∊⍴⍵:⍵ ⋄ (~IsScripted OnEach ⍵)/⍵}∊prev.{0∊⍴nl←⎕NL ⍵:0⍴# ⋄ ⍎¨nl}¯9  ⍝ unscripted children
          refs,←next ⋄ prev←next
      :EndWhile
    ∇

    :EndSection





    :Section Lookup

    ∇ ok←HasLinks
      :If ok←×⎕NC'⎕SE.Link.Links'
      :AndIf ok←×≢⎕SE.Link.Links
          ⎕SE.Link.Links/⍨←0≠⎕NC ⎕SE.Link.Links.ns
          ok←×≢⎕SE.Link.Links
      :EndIf
    ∇
    ∇ linkns←LookupFile file;dirs;inx;links;mask
    ⍝ look up which linked directory has file
      :If HasLinks
          dirs←(links←⎕SE.Link.Links).dir
      :AndIf ∨/mask←dirs Begins¨⊂file
          inx←⊃⍒mask×≢¨dirs ⍝ longest directory containing file
          linkns←inx⊃links
      :Else
          linkns←⍬
      :EndIf
    ∇
    ∇ linkns←{links}LookupRef nsref;linked;links;nss
    ⍝ lookup which linked namespace has nsref
      linkns←⍬
      :If 900⌶⍬
          :If HasLinks
              links←⎕SE.Link.Links
          :Else
              :Return
          :EndIf
      :EndIf
      nss←⍎¨links.ns
      :While ~linked←nsref∊nss
      :AndIf ~IsRoot nsref
          nsref←nsref.##
      :EndWhile
      :If linked
          linkns←(nss⍳nsref)⊃links
      :EndIf
    ∇
    ∇ {opts}←{defopts}DefaultOpts opts;Default;nl
    ⍝ Get default modifiers for link options namespace
      :If ''≡0⍴opts ⋄ opts←⎕SE.Dyalog.Array.Deserialise opts ⍝ pseudo array notation (experimental)
      :Else ⋄ opts←⎕SE.Link.⎕NS opts  ⍝ duplicate namespace to avoid changing caller's, and to avoid having cross-refs between # and ⎕SE
      :EndIf
      Default←opts.{(⊆⍺){0=⎕NC ⍺:⍎⍺,'←⍵'}¨⊆⍵}
      'source'Default'auto'
      'watch'Default(1+CanWatch)⊃'ns' 'both'
      'flatten' 'caseCode' 'forceExtensions' 'forceFilenames' 'fastLoad'Default 0
      'beforeWrite' 'beforeRead' 'getFilename' 'customExtensions'Default''
      'codeExtensions'Default⊂'aplf' 'aplo' 'apln' 'aplc' 'apli' 'dyalog' 'apl' 'mipage'
      opts.codeExtensions{⍵↓¨⍨⍺=⊃¨⊆⍵}∘⊆⍨←'.'
      'typeExtensions'Default 0 2⍴0 ''
      opts.typeExtensions{_←⍺⍪⍵ ⋄ _[∪⍳⍨⊣/_;]}←↑(2 'apla')(3 'aplf')(4 'aplo')(9.1 'apln')(9.4 'aplc')(9.5 'apli')
      :If ~900⌶⍬ ⋄ :AndIf ~0∊⍴nl←defopts.⎕NL ¯2 ⍝ some more custom defaults
          nl Default¨defopts⍎¨nl
      :EndIf
    ∇

    :EndSection




    :Section Link Private function    ⍝ to avoid clobber auto-complete in ⎕SE.Link

    ∇ src←GetRefSource ns
      :Trap 16 ⋄ src←⎕SRC ns  ⍝ scripted namespace
      :Else ⋄ src←⎕NULL  ⍝ unscripted namespace
      :EndTrap
    ∇
    ∇ src←{ns}GetAplSource name;nc
    ⍝ src is a vector of text vectors, unless unscripted namespace with get ⎕NULL
    ⍝ name may be empty to get the source of ns
      :If 0∊⍴name
          src←GetRefSource ns
      :Else
          :If 900⌶⍬ ⋄ ns←⎕NS ⍬ ⋄ :EndIf
          nc←|ns.⎕NC⊂,name
          :Select nc
          :Case 2.1 ⍝ variable
              :Trap 11 ⋄ src←⎕SE.Dyalog.Array.Serialise ns⍎name
              :Else ⋄ Error'Array cannot be serialised: ',(⍕ns),'.',name
              :EndTrap
          :CaseList 3.1 3.2 4.1 4.2 ⋄ src←ns.⎕NR name ⍝ tradfn/dfn/tradop/dop
          :CaseList 9.1 9.4 9.5 ⋄ src←GetRefSource ns⍎name ⍝ ns/class/interface
          :Else ⋄ Error('Cannot get source of ',(⍕ns),'.',name,': invalid name class (',(⍕nc),')')
          :EndSelect
      :EndIf
    ∇
    ∇ src←GetFileSource file;type
      src←⍬  ⍝ ⍬ means failure - empty file produces 0⍴⊂''
      :Trap 0
          :If 1=type←1 ⎕NINFO file ⋄ src←⎕NULL  ⍝ directory → namespace
          :ElseIf 2=type ⋄ src←GetFile file     ⍝ file
          :EndIf
      :EndTrap
    ∇

    ∇ (name nc)←{where}Fix(name src);file;invalid;monitor;names;nc;stops;trace;unnamed
    ⍝ Fix source and return names and nameclass
    ⍝ src may be actual source (⎕NULL or vector of strings) or file name (string)
    ⍝ nameclass is 0 if no valid source was found, ¯1 if name is invalid, ¯9.1 if unscripted namespace
      :If 900⌶⍬ ⋄ where←⎕DMX.(⎕NS ⍬) ⋄ :EndIf  ⍝ fix in dummy namespace that cannot break anything (e.g. ':Namespace' '##.⎕IO←0' ':EndNamespace')
      :If 1=≡src ⋄ src←'file://',file←src ⋄ :Else ⋄ file←'' ⋄ :EndIf  ⍝ file name given instead of source
      ⍝ attempt to fix as named script because this is the most commly expected format
      :If (⌊|where.⎕NC⊂name)∊3 4 ⋄ (stops trace monitor)←(where.⎕STOP name)(where.⎕TRACE name)(⊣/where.⎕MONITOR name)  ⍝ remember stops
      :Else ⋄ stops←trace←monitor←⍬
      :EndIf
      :Trap 11
          ⍝ actual apl name may be different from what was expected
          names←2 where.⎕FIX src  ⍝ fn/op/script - can work from file
          :If 1=≢names ⋄ name←⊃names ⋄ nc←where.⎕NC⊂name
          :Else ⋄ name←'' ⋄ nc←0  ⍝ multiple names in single file not supported
          :EndIf
          :If ((⌊|nc)∊3 4)∧(0∨.<⊃∘⍴¨stops trace monitor)  ⍝ restore stops, traces and monitor - monitor timing information will be lost
              stops where.⎕STOP name ⋄ trace where.⎕TRACE name ⋄ monitor where.⎕MONITOR name
          :EndIf
          :Return  ⍝ named script fixed
      :Else
          ⍝required←116=⎕DMX.ENX  ⍝ 2 ⎕FIX failed because cannot read :Required file
          unnamed←121=⎕DMX.ENX  ⍝ 2 ⎕FIX failed because script was unnamed
      :EndTrap
      ⍝ name must be valid because we define it in the following code
      :If ¯1=⎕NC,name ⋄ :AndIf ~where IsRootName name ⋄ nc←¯1 ⋄ :Return ⋄ :EndIf
      :If unnamed  ⍝ unnamed script
          name where.{⍎⍺,'←⎕FIX ⍵'}src  ⍝ can work from file
          nc←where.⎕NC⊂,name
          :Return  ⍝ unnamed script fixed
      :EndIf
      ⍝ remaining possibilities are array or trad ns
      :If ~0∊⍴file  ⍝ they both require source, not filename
          src←GetFileSource file
      :EndIf
      :If src≡⎕NULL  ⍝ trad namespace - was not tested before because the 1=1⎕NINFO would have been costy
          name where.⎕NS'' ⋄ nc←¯9.1
          :Return  ⍝ trad ns created
      :EndIf
      :Trap 0
          name where.{⍎⍺,'←⍵'}⎕SE.Dyalog.Array.Deserialise src  ⍝ array
          nc←where.⎕NC⊂,name
      :Else
          name←'' ⋄ nc←0  ⍝ unknown
      :EndTrap
    ∇
    ∇ ok←target QFix(file name tie);changed;nc;src
      :If tie ⋄ src←file ⍝ tie to file
      :Else ⋄ src←GetFileSource file  ⍝ pure source - not tied
      :EndIf
      :If tie ⋄ changed←0∊⍴target CurrentFileName name ⍝ file not tied - need to tie it
      :Else ⋄ changed←0 ⋄ :EndIf  ⍝ need to detect whether file has changed
      :If changed ⋄ :OrIf FileHasChanged target name file((~tie)/src)  ⍝ pay the price of not generating a spurious refix when source is already in sync
          (name nc)←target Fix(name src)
          ok←~nc∊0 ¯1
      :Else ⋄ ok←1 ⋄ :EndIf
    ∇
    ∇ (file oldfile nc)←opts(depth DetermineFileName)(where name oldname src);cache
    ⍝ opts cached for performance on ns lookup
      cache←opts,opts.(dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)
      :If depth ⋄ (file oldfile nc)←↓⍉↑cache∘DetermineFileNameSub¨↓⍉↑(where name oldname src)
      :Else ⋄ (file oldfile nc)←cache DetermineFileNameSub(where name oldname src)
      :EndIf
    ∇
    ∇ (file oldfile nc)←opts DetermineFileNameSub(where name oldname src);beforeWrite;caseCode;dir;ext;fastLoad;flatten;forceExtensions;forceFilenames;getFilename;isroot;nc;ns;oldfile;path;ref;subdir;typeExtensions;userfile
    ⍝ what should the file name be according to link
    ⍝ src may be the (nested) text source of item, or may be the scalar name class
    ⍝ where must have been through U.NormNs
      ⍝ values cached for performance on ns lookup
      (opts dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)←opts
      :If 0=⎕NC where ⋄ oldfile←'' ⋄ ref←⎕NULL   ⍝ namespace doesn't exist - src or nc ought to be provided
      :Else ⋄ ref←⍎where ⋄ oldfile←ref CurrentFileName name         ⍝ Grab file info before ⎕FIX might destroy it
      :EndIf
      file←(oldname≡name)/oldfile  ⍝ if object was renamed we don't have a file name any more
      :If 0∊⍴src  ⍝ no information about item - item must exist
          nc←ref NameClass name  ⍝ no source : item must exist
          ⍝:If 0=nc ⋄ Warn'Source of name ',where,'.',name,' doesn''t exist' ⋄ :EndIf
      :ElseIf 0=≡src ⋄ nc←src ⍝ name class is given
      ⍝:ElseIf opts.fastLoad ⋄ nc←0  ⍝ nope - fastLoad is used only by FixFiles which then shouldn't call DetermineFileName
      :Else   ⍝ infer name class from (non-empty) source
          (name nc)←Fix name src  ⍝ fix in dummy namespace
      :EndIf
      :If nc∊0 ¯1 ⋄ file←'' ⋄ :Return ⋄ :EndIf  ⍝ invalid source or name
      ⍝ trad namespace are given name class ¯9.1
      :If isroot←nc=¯9.1 ⋄ isroot←ns≡where,'.',name ⋄ :EndIf ⍝ we're asking for the root of the link
      :If 0=≢file                   ⍝ no existing file name for it
      :OrIf forceFilenames     ⍝ force using the default
          :If isroot  ⍝ if we're asking for opts.ns then the answer is opts.dir
              file←dir
          :Else
              :If ~flatten                ⍝ flatten prevents subdirectory hierarchy
                  file←(≢ns)↓where              ⍝ Add sub.namespace structure
                  ((file='.')/file)←'/'            ⍝ Convert dots to /
              :Else  ⍝ when flattening, use the same dir as the old file (if any)
                  file←(≢dir)↓¯1↓⊃⎕NPARTS oldfile  ⍝ if 0∊⍴oldfile, then file remains empty
              :EndIf
              file←dir,file               ⍝ Add link directory
              file,←'/',name                  ⍝ Add object name
          :EndIf
          file,←typeExtensions Tail nc               ⍝ Add extension
      :EndIf
      file←(dir CaseCode flatten)⍣caseCode⊢file ⍝ case coded-name (if required)
      :If ¯9.1=nc ⋄ file←0 NormDir file ⋄ :EndIf  ⍝ for ⎕NPARTS to work on it
      (subdir file ext)←⎕NPARTS path←file
      :If forceExtensions∨0=≢ext
      ⍝:OrIf ~⎕NEXISTS path    ⍝ why ??? file is not supposed to exist yet
          ext←typeExtensions Tail nc
      :EndIf
      :If isroot<forceFilenames ⋄ file←CaseCodePart⍣caseCode⊢name ⋄ :EndIf  ⍝ forceFileNames does not affect directory - only leaf name
      file←subdir,file,ext
      file←ApplyOldExtn⍣(~forceExtensions)⊢file  ⍝ doesn't sound like a good idea - the existing .dyalog file could define something different (in particular if one of the two files is an array and casecode is off)
      ⍝ Allow user to determine file name - they return '' to give up
      :If 3=(⍎ns).⎕NC getFilename
      :AndIf 0<≢userfile←(ns⍎getFilename)'getFilename'opts file(ns,'.',name)(|nc)(ns,'.',oldname)
          file←userfile
      :EndIf
    ∇
    ∇ expname←expname(forcefile MergeFileName forceext)actname;actdir;actext;actfile;expdir;expext;expfile
    ⍝ enforce forceFilenames/forceExtensions on actual file name, based on expected file name
      :If (forcefile∨forceext)∧(actname≢expname)
          :If Slash⊃⌽actname  ⍝ directory - ⎕NPARTS won't work
              expname←(1+forcefile)⊃actname expname
          :Else
              ((expdir expfile expext)(actdir actfile actext))←⎕NPARTS¨expname actname
              expname←actdir,((1+forcefile)⊃actfile expfile),((1+forceext)⊃actext expext)
          :EndIf
      :EndIf
    ∇

    ∇ (ns name nc)←CurrentAplName file;fullname;info;row
      :If 0≠≢info←↑GetFileInfo file  ⍝ file actually linked by interpreter
      :AndIf (≢info)≥row←info[;5 6]⍳0 0  ⍝ file defines a single object
          (name ns)←info[row;1 2] ⋄ name←⍕name ⍝ first column is sometimes refs
          nc←ns NameClass name  ⍝ no need to protect fully-qualified name
          (ns name)←SplitNs(⍕ns),'.',name ⋄ ns←NormNs ns  ⍝ NormNs due to 5174⌶ sometimes reporting full path in first column
      :Else
          ns←name←'' ⋄ nc←¯1
      :EndIf
    ∇
    ∇ (where expname actname nc)←opts DetermineAplName files;cache
    ⍝ opts cached for performance on ns lookup
      cache←opts,opts.(dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)
      (where expname actname nc)←⊃⍣(1=≡,files)⊢↓⍉↑cache∘DetermineAplNameSub¨⊆files
    ∇
    ∇ (where expname actname nc)←opts DetermineAplNameSub file;beforeWrite;caseCode;dir;fastLoad;flatten;forceExtensions;forceFilenames;fullname;getFilename;ns;src;subdir;subfile;typeExtensions
    ⍝ ns is the target namespace
    ⍝ expname is apl name expected from file name
    ⍝ actname is actual list of names fixed from file
    ⍝ nc is name class of name - returns ¯1 on invalid name and 0 on invalid/missing source
    ⍝ opts cached for performance on ns lookup
      (opts dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)←opts
      :If fastLoad ⋄ src←''     ⍝ do not spend time inspecting source
      :Else ⋄ src←GetFileSource file
      :EndIf
      file←dir StripCaseCode flatten⊢file  ⍝ always strip case code - apl name can't have them anyways
      (subdir file)←2↑⎕NPARTS file  ⍝ drop extension
      :If 0=≢file ⋄ subdir←¯1↓subdir ⋄ :EndIf  ⍝ drop trailing slash for directories
      (where expname)←SplitNs fullname←ns,DotSlash subfile←(≢dir)↓subdir,file
      :If flatten ⋄ where←⍕ns ⋄ :EndIf     ⍝ all subdirectories link to linked namespace
      :If fastLoad ⋄ (actname nc)←expname 0  ⍝ settle with expname
      :ElseIf 0=≢src ⋄ (actname nc)←'' 0             ⍝ no source
      :Else ⋄ (actname nc)←Fix expname src           ⍝ inspect source
      :EndIf
      :If '.'∊subfile ⋄ nc←¯1      ⍝ invalid APL name, which would otherwise go unnoticed because ⎕NC would interpret it as namespace separator
      :ElseIf (0=≢where)∧(nc=¯9.1) ⋄ :AndIf # IsRootName actname ⋄ where←actname  ⍝ file is linked dir and ns is a root - where≡expname≡actname≡ns
      :ElseIf ¯1=⎕NC where ⋄ :AndIf ~# IsRootName where ⋄ nc←¯1  ⍝ invalid namespace path - avoid costy IsRootName if possible
      :EndIf
    ∇



    ∇ outFail←opts WriteFiles(ns dir);count;dir;files;i;inx;mask;names;nsref;ok;oldfiles;src;tradfiles;tradnames
    ⍝ Write items to file in folders
    ⍝ ns must be a fully specified unscripted namespace
    ⍝ arrays not supported
      outFail←0⍴⊂'' ⋄ nsref←⍎ns
      ⍝ Create directory for namesapce
      3 ⎕MKDIR dir ⋄ outFail,←(~⎕NEXISTS dir)/⊂ns  ⍝ can't create directory
      ⍝ Write children to files (except trad namespaces)
      :If 0≠≢names←nsref.⎕NL-NameClasses 0
          src←nsref GetAplSource¨names
          mask←0=≢¨src     ⍝ can't get source
          outFail,←(ns,'.')∘,¨mask/names
          (names src)←(~mask)∘/¨(names src) ⋄ count←≢names
          (files oldfiles)←2↑opts(1 DetermineFileName)(count/⊂ns)names names(count/⊂'')  ⍝ names are known to exist so don't provide source
          :If ∨/mask←(inx←⍳⍨819⌶¨files)≠(⍳≢files) ⍝ TODO should really test the whole list of files after recursion, in case beforeWrite messed up the names
              ⍝ cannot let user do this on any platform - if the directory is moved to windows then the user will be screwed
              names←names[,(mask/inx),[1.5]⍸mask]
              Error'File name case clash - try using caseCode←1:',⍕(ns,'.')∘,¨names
          :EndIf
          mask←src∊⎕NULL  ⍝ unscripted namespaces
          (tradnames tradfiles)←mask∘/¨(names files)
          (files oldfiles names src)/⍨←⊂(~mask)
          :If 0≠≢files
              :If 3=opts.(⎕NC beforeWrite)  ⍝ user callback on file write - not on directories
                  mask←(≢files)⍴1
                  :For i :In ⍳⍴files
                      mask[i]←(⍎opts.beforeWrite)'beforeWrite'opts(i⊃files)(ns,'.',i⊃names)(nsref NameClass i⊃names)(ns,'.',i⊃names)src
                  :EndFor
                  (files oldfiles names src)/⍨←⊂mask  ⍝ keep what was not processed by user
              :EndIf
              :If 0∊mask←~HasNewlines¨∊¨src  ⍝ cannot write newlines
                  outFail,←(ns,'.')∘,¨(~mask)/names
                  (files oldfiles names src)/⍨←⊂mask
              :EndIf
              mask←src Into¨files  ⍝ failed to write
              outFail,←(ns,'.')∘,¨(~mask)/names
              :If ∨/mask←mask∧(oldfiles≢¨files)∧(0≠≢¨oldfiles)  ⍝ delete oldfilename which was incorrect if write was successful
                  ⎕NDELETE¨mask/oldfiles
              :EndIf
          :EndIf
          :If 0≠≢tradfiles ⍝ recurse on unscripted namespaces
              tradnames←(ns,'.')∘,¨tradnames
              outFail,←⊃,/opts∘WriteFiles¨↓tradnames,[1.5]tradfiles
          :EndIf
      :EndIf
    ∇

    ∇ (files dirs)←opts ListFiles dir;hidden;list;mask
      list←↑0 1 6 ⎕NINFO⍠1⍠'Recurse' 1⊢dir,'/*'     ⍝ recursive listing of everything  list[filename type hidden;]
     
      mask←1=list[3;] ⋄ list←¯1↓list                ⍝ mask for hidden items
      hidden←mask/list ⋄ list/⍨←~mask               ⍝ crop hidden (files and) folders
      hidden←(1=hidden[2;])/hidden[1;]              ⍝ keep directories only (files have already been removed from list)
      hidden←hidden,¨'/'                            ⍝ protect against similarly named files
      hidden,←('.'=⊃¨∊¨1↓¨⎕NPARTS¨list[1;])/list[1;]⍝ files and directories that start with a '.' are considered hidden too
      list/⍨←~∨⌿hidden∘.Begins list[1;]             ⍝ filter away things that come below hidden directories
     
      dirs←(1=list[2;])/list[1;]                    ⍝ second column has 1 for dirs
      dirs←((⊂dir),{⍵[⍋⍵]}dirs),¨'/'                ⍝ all directories (including self)
     
      files←(2=list[2;])/list[1;]                   ⍝ second column has 2 for files; first column is filename
      files/⍨←opts HasExtn files                    ⍝ must be of correct extension
      files←files[GradeFiles files]                 ⍝ dirs then quads then files
    ∇

    ∇ {inFail}←opts FixFiles(target source);FixFile;actnames;actnc;allfiles;allnames;dirs;expfiles;expnames;exts;files;hidden;i;inx;list;mask;names;ndirs;nss;parents;quadfiles;source;tie
    ⍝ Load items from files in folders
      inFail←0⍴⊂''
      (files dirs)←opts ListFiles source
      ndirs←≢dirs ⋄ allfiles←dirs,files
     
      (parents expnames actnames actnc)←opts DetermineAplName allfiles  ⍝ expected names (one per file), actual names (one list per file), actual name classes (one list per file)
      :If opts.fastLoad  ⍝ do not spend time avoiding name clashes - actnc will be all 0's anyway
          allnames←parents('.'JoinEach)expnames  ⍝ do not infer true apl name from source
      :Else
          mask←actnc∊¯1 0    ⍝ invalid names or source
          inFail,←mask/allfiles
          (allfiles parents expnames actnames actnc)/⍨←⊂~mask    ⍝ keep only names that are valid
          ndirs←+/ndirs↑~mask
          allnames←parents('.'JoinEach)actnames  ⍝ fully qualified names
          :If ∨/mask←(inx←⍳⍨allnames)≠(⍳≢allnames)
              files←allfiles[,(mask/inx),[1.5]⍸mask]
              Error'Files produce clashing APL names:',⍕files
          :EndIf
      :EndIf
     
      ⍝ rename files if incorrectly named - cannot work with opts.fastLoad
      :If (0<≢allfiles)∧opts.(fastLoad<forceExtensions∨forceFilenames)
          expfiles←⊃opts(1 DetermineFileName)parents actnames actnames actnc
          expfiles←expfiles(opts.forceFilenames MergeFileName opts.forceExtensions)¨allfiles
          :If ∨/mask←expfiles≢¨allfiles
              :If (≢expfiles)≠(≢∪819⌶expfiles)
                  Error'Forcing file names would produce clashing file names: use forceFilenames=0 or caseCode=1'
              :Else
                  ⍝ because APL names don't clash, we now expfiles won't clash either
                  ⍝ however expfiles may overlap allfiles, producing an error at intermediate steps (⎕NMOVE should fail, because ⍠'IfExists' 'Error')
                  (mask/expfiles)Relocate(mask/allfiles)
                  allfiles←expfiles
              :EndIf
          :EndIf
      :EndIf
     
      :If 3=⎕NC opts.beforeRead ⍝ user handler defined?
          mask←(⍴allfiles)⍴1
          :For i :In ⍳⍴allfiles
              mask[i]←(opts⍎opts.beforeRead)'beforeRead'opts(i⊃allfiles)(i⊃allnames)(|i⊃actnc) ⍝ return 1 to continue else 0
          :EndFor
          (allfiles parents expnames actnames actnc)/⍨←⊂mask    ⍝ keep what was not processed by user
      :EndIf
     
      tie←'both'≡opts.watch ⍝ tie to file if watching both ways
      FixFile←tie∘{(target file name)←⍵ ⋄ target QFix file name ⍺}
      ⍝ create namespaces for directories and load quadVars.apln
      (dirs names)←ndirs↑¨(allfiles allnames)
      :If ~0∊⍴dirs
          :If ~opts.flatten                               ⍝ If we are not flattening, create nss
              nss←names ⎕NS¨⊂⍬
              :If ∨/mask←0=≢¨nss   ⍝ could not create namespace
                  inFail,←mask/names
              :EndIf
          :Else
              nss←target   ⍝ all files fixed in target namespace
          :EndIf
          ⍝ set sysvars before anything else - these files are produced by Acre and must be supported
          :If ∨/mask←⎕NEXISTS¨quadfiles←dirs,¨⊂'quadVars.apln'
              mask←mask\~FixFile¨↓nss,mask⌿quadfiles,[1.5]⊂'quadVars'
              inFail,←mask/quadfiles
          :EndIf
      :Else ⋄ quadfiles←0⍴⊂''
      :EndIf
     
      ⍝ fix individual files
      (files names)←ndirs∘↓¨(allfiles allnames)
      (files names)/⍨←⊂~files∊quadfiles
      :If ~0∊⍴files
          :If ~opts.flatten                               ⍝ If we are not flattening, create nss
              nss←⍎∘Parent¨names
          :Else
              nss←target   ⍝ all files fixed in target namespace
          :EndIf
          mask←~FixFile¨↓nss,files,[1.5]names ⍝ try it and return only failures
          inFail,←mask/files
      :EndIf
    ∇

    :EndSection





    :Section UI

    WARNING←LOG←0⍴⊂''

    ∇ {msg}←{header}Warn msg
    ⍝ Warn user
      :If 900⌶⍬ ⋄ header←'Link Warning: ' ⋄ :EndIf
      WARNING,←⊂⎕←header,msg
    ∇
    ∇ {msg}←Log msg
    ⍝ Debug information
      LOG,←⊂msg
      :If debug≠0 ⋄ ⎕←msg ⋄ :EndIf
    ∇

    :EndSection



    :Section DEVT
    ∇ UpdateUCMD;from;to
      from←(⊃⎕NPARTS 4⊃5179⌶⎕SE.Link.U),'../../SALT/spice/Link.dyalog'
      to←(2 ⎕NQ'.' 'GetEnvironment' 'DYALOG'),'/SALT/spice/Link.dyalog'
      ⎕←'Copying "',from,'" → "',to,'"'
      to ⎕NCOPY⍠'IfExists' 'Replace'⊢from
      ⎕←⎕SE.UCMD']UReset'
    ∇
    :EndSection

:EndNamespace
