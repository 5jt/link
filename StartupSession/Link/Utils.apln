:Namespace U ⍝ Utilities
    ⎕IO←1

    :Section Constants
    isWindows←'Win'≡3↑⊃# ⎕WG'APLVersion'
    ∇ (canwatch dotnetcore)←_CanWatch;⎕USING
      :Trap 0
        ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
          dotnetcore←(~isWindows)∨(,'1')≡2 ⎕NQ'.' 'GetEnvironment' 'DYALOG_NETCORE'
          ⎕USING←',System',(~dotnetcore)/'.dll'
          canwatch←9.6=⎕NC⊂'System.IO.FileSystemWatcher'
      :Else
          canwatch←dotnetcore←0
      :EndTrap
    ∇
    (CanWatch DotNetCore)←_CanWatch ⍝ cache result
    ∇ d←debug
      :If 0=⎕NC'##.DEBUG'
          d←##.DEBUG←0
      :Else
          d←##.DEBUG
      :EndIf
    ∇
    :EndSection


    :Section APL covers
      OnEach←{ ⍝ ¨ without prototype call on empty
          0∊⍴⍵:⍵   ⍝ if empty return empty
          ⍺←⊢      ⍝ ambivalent
          1:_←⍺ ⍺⍺¨⍵   ⍝ shy call
      }
    :EndSection


    :Section Stack Frames      ⍝ Tacit necessary to avoid them
    Resignal←⎕SIGNAL{⍺←'' ⋄ ⍵/⊂⎕DMX.(('EN'(EN+11×EN=0))('EM' EM)('Message'(Message,⍺)))}
        Check←{⍺←0⋄⍺}⍴⍨¯1∊∘⎕NC⊢⊆⍨'/'≠⊢ ⍝ leave early if any bad name
    If←⍴⍨
    ERRNO←99              ⍝ official API error number
    Error←⎕SIGNAL∘ERRNO
    :EndSection



    :Section Strings
    Shortest←{⍵⊃⍨{⍵⍳⌊/⍵}≢¨⍵}                ⍝ Shortest string in list
    Case←{⍺(819⌶)¨⍵}                        ⍝ Upper/Lower case
    LCase←{819⌶⍵}                           ⍝ Lower case
    ⍝Join←{(⍕⍺),⍺⍺,(⍕⍵)}                     ⍝ Join ⍺ and ⍵ using ⍺⍺
    JoinList←{⊃,/1↓,(⊂⍺⍺),[1.5],⍵}          ⍝ Join list of items with ⍺⍺
    JoinEach←{,/⍺,⍺⍺,[1.5]⍵}                ⍝ Join¨
    Slash←∊∘'/\'                            ⍝ Mark slashes
    Parts←{⍵⊆⍨~Slash ⍵}                     ⍝ Path parts
    TilLast←{⍵↓⍨-⍺⍳⍨⌽⍵}
    Path←'/'∘TilLast                        ⍝ Until last slash
    Parent←'.'∘TilLast                      ⍝ Until last dot
    PadThis←{⍵,'⎕THIS'/⍨0=≢⍵}               ⍝ Default path to here
    NsExpr←{'''',⍵,'''⎕NS⍬'}                ⍝ Expression to create namespace
    Begins←{⊃⍺⍷⍵}                           ⍝ ⍵ starts with ⍺
    WinSlash←'\'@Slash⍣isWindows            ⍝ force windows slashes only on windows machines
    DotSlash←'.'@Slash                      ⍝ Convert dots to slashes
        Combine←{(⍕⍺),⍨(326≠⎕DR ⍺)/'.',⍨⍕⍵}/
    List←{∊{' ',⍕⍵}¨⍵}
      Arrow←{                               ⍝ appropriate symbol to show ns-dir connection
          lr←'←→'/⍨2 2⊤'ns' 'dir' 'both'⍳⊂⍵.watch
          ⍵.ns,' ',lr,' ',WinSlash ⍵.dir
      }

    :EndSection


    :Section Covers for I-beams and other built-ins
    CurrentFileName←{4⊃⍺.(5179⌶)⍵}   ⍝ Return current file name tied to apl name ⍵ in namespace ⍺
    CurrentHash←{7⊃⍺.(5179⌶)⍵}       ⍝ Return current hash of tied file
    Where←{⍵⌿⍺}                      ⍝ Filter as function
    GetFileInfo←{5174⌶⍵}             ⍝ Return links to file
      GetFile←{
          11::⊃⎕NGET ⍵ 1                     ⍝ 17.0 Unicode
          ⊃⎕NGET⍠'ContentType' 'APLCode'⊢⍵ 1 ⍝ 17.1+ Classic
      }
      GetInfos←{
          ''≡0⍴⍵:∇'name' 'parent' 'nc' 'file' 'line' 'lines' 'hash' 'ts'⍳⊂⍵
          ⍵∘⊃¨5177⌶⍬
      }
    Untie←{1:_←5178⌶⍵}  ⍝ untie an apl name from its file
    ∇ r←RemoveFileLinksIn rootns;all;allrefs;urefs;mask;t;remove
     ⍝ Find all file system links to objects below rootns, and remove using 5178⌶
     ⍝ Return number of links broken
      allrefs←2⊃¨all←5177⌶⍬
      t←urefs←∪allrefs
      mask←(≢urefs)⍴0
      :If 0≠≢t
          :Repeat
              mask∨←t∊rootns ⍝ Have we reached rootns?
              t←t.##         ⍝ Move all pointers up to parent
          :Until t≡t.##      ⍝ Continue until everything is "root"
      :EndIf
      :If 0≠r←≢remove←(allrefs∊mask/urefs)/all ⍝ links to be removed
          r←+/5178⌶¨(⍕¨2⊃¨remove),¨'.',¨⍕¨1⊃¨remove
      :EndIf
    ∇
    :EndSection



    :Section Files

    ∇ path←Enslash path
      path,←'/'/⍨~'/\'∊⍨⊃⌽path ⍝ append trailing slash if missing
    ∇
    ∇ path←Deslash path
      path↓⍨←-+/∧\⌽path∊'/\'  ⍝ remove trailing slash
    ∇
    NormFile←{⍺<0=≢⍵:⍵ ⋄ ∊1⎕NPARTS ⍵}  ⍝ ⍺=1 : '' means current directory
    ∇ dir←trail NormDir dir
      dir←∊1 ⎕NPARTS dir            ⍝ normalise - '' means current dir
      :If trail ⋄ dir←Enslash dir
      :Else ⋄ dir←Deslash dir
      :EndIf
    ∇
    ∇ mask←opts HasExtn files;act;exp;regex
    ⍝ mask of files that have valid extensions
      exp←opts.(codeExtensions,customExtensions,⊢/typeExtensions) ⍝ all interesting extensions
      act←{1↓⊃⌽⎕NPARTS ⍵}¨,⊆files    ⍝ actual extensions
      ⍝ regex special characters : .$^{[(|)*+?\
      regex←'^' '$' '[\^\$]' '\*' '\?'⎕R'^' '$' '\\\0' '.*' '.'⊢exp ⍝ convert glob to regex
      mask←1@(⎕IO+regex ⎕S 2⊢act)⊢(⍴act)⍴0
      :If (1=≡,files)∨(0=⍴⍴files) ⋄ mask←⊃mask ⋄ :EndIf
    ∇

      Tail←{ ⍝ ⍺:typeExtensions; ⍵:nc
          ¯9=⍵:'/'    ⍝ trad namespace are given name class ¯9
          (types exts)←↓⍉⍺
          exts,←⊂'dyalog'
          exts,¨⍨←'.'
          exts⊃⍨⌊/types⍳⍵,⌊⍵
      }

      ApplyOldExtn←{ ⍝ Correct new extension to .dyalog if old source exists
          (dir name ext)←⎕NPARTS ⍵
          ext≡'.dyalog':⍵
          alt←dir,name,'.dyalog'
          (⎕NEXISTS alt)>(⎕NEXISTS ⍵):alt
          ⍵
      }

    Ancestry←{((¯1+⍵⍳'/')↑⍵)∘,¨,\('/'=⍵)⊂⍵}

    FileHash←{2 ⎕NQ #'GetBuildID' ⍵}

    IsDir←{0::0 ⋄ 1=1 ⎕NINFO ⍵}

      Into←{ ⍝ Put vtv ⍺ into file ⍵ - return success
          22::0                  ⍝ no file access
          _←3 ⎕MKDIR⊃1 ⎕NPARTS ⍵ ⍝ create dir if needed
          1⊣(⊂⍺)⎕NPUT ⍵ 1        ⍝ overwrite
      }

    ∇ name←CaseCodePart name;bin;digits;len;⎕IO
        ⍝ case-code a string
      ⎕IO←0
      →0 If 0=≢name  ⍝ empty name doesn't get case coded
      bin←name≠819⌶name
      len←⌈3÷⍨≢bin
      digits←2⊥⌽⍉⌽len 3⍴bin↑⍨3×len
      digits↓⍨←+/∧\0=digits
      name,←'-',⎕D[digits,0/⍨⍬≡digits]
    ∇
    ∇ name←StripCaseCodePart name;code;length;mask;⎕IO
        ⍝ strip case code from a string
      ⎕IO←0
      length←(⌽name)⍳'-'
      →0 If length∊0,≢name   ⍝ case code must be after hyphen
      code←⎕D⍳(-length)↑name
      name←((-length+1)↓name)
      →0 If code∨.>7         ⍝ case code must be octal digits
      mask←⌽,⍉2 2 2⊤code     ⍝ boolean mask of upper-case
      →0 If~(⊂(≢name)↓mask)∊⍬(,0)(0 0)  ⍝ mask must be padded with 0-2 zeros
      name←((≢name)↑mask)Case name
    ∇
    ∇ name←(dir CaseCode flatten)name;ext;file;parts;path
    ⍝ case-code a file located under linked dir
      :If name≡dir ⋄ :Return ⋄ :EndIf  ⍝ would wrongfully cut name because of missing trailing slash
      (path file ext)←1 ⎕NPARTS name
      :If flatten  ⍝ case code file name only
          file←CaseCodePart file
          name←∊path file ext
      :Else  ⍝ case code sub-directories too
          path←(≢dir)↓path       ⍝ do not case-code linked directory
          parts←(Parts path),⊂file
          parts←CaseCodePart¨parts      ⍝ case-code each part of path independently
          name←'/'JoinList(⊂dir),parts
          name,←ext
      :EndIf
    ∇
    ∇ name←(dir StripCaseCode flatten)name;ext;file;parts;path
    ⍝ strip case code from a file name located under linked dir
      :If ~'-'∊(≢dir)↓name  ⍝ no casecode
      :OrIf name≡dir  ⍝ would wrongfully cut name because of missing trailing slash
          :Return
      :EndIf
      (path file ext)←1 ⎕NPARTS name
      :If flatten   ⍝ only file name is case coded
          file←StripCaseCodePart file
          name←∊path file ext
      :Else  ⍝ sub-directories are case-coded
          path←(≢dir)↓path       ⍝ do not case-code linked directory
          parts←(Parts path),⊂file
          parts←StripCaseCodePart¨parts      ⍝ case-code each part of path independently
          name←'/'JoinList(⊂dir),parts
          name,←ext
      :EndIf
    ∇

    ∇ order←GradeFiles files
    ⍝ slashes after all chars and quads before all
    ⍝ in "descending" order into folders: must process parent folders first
      order←⍋¯1@{9109=⍵}9999999@{47=⍵}↑⎕UCS¨files
    ∇
    ∇ {r}←to Relocate from;i;nextfrom;nextto
    ⍝ move list of files, updating file names as we go through the list
      r←⍬
      :While ~0∊⍴to
          (nextto nextfrom)←⊃¨(to from) ⋄ (to from)↓⍨←1
          :If nextto≢nextfrom
              r,←nextto ⎕NMOVE nextfrom
              from←(nextfrom ⎕R nextto)from  ⍝ update directories in particular
          :Else ⋄ r,←1   ⍝ no need to copy
          :EndIf
      :EndWhile
    ∇

    :EndSection





    :Section Namespaces

    ⍝ Supported name classes
    _NameClasses←2.1              ⍝ array
    _NameClasses,←3.1 3.2 4.1 4.2 ⍝ tradfn/dfn/tradop/dop
    _NameClasses,←9.1 9.4 9.5     ⍝ ns/class/interface
    NameClasses←{(~⍵)↓_NameClasses}  ⍝ 0=exclude arrays ⋄ 1=include arrays

      IsScripted←{
          0<≢# CurrentFileName ⍵:1          ⍝ tied namespaces are always scripted !!! tied scripted namespace where file is lost produce a pop up at ⎕SRC time !!!
          16::0
          1⊣⎕SRC ⍵
      }
        RootOf←{⍵.##}⍣≡
    IsRoot←{⍵=⍵.##}                         ⍝ is namespace a root
    SplitNs←{t←1+d←-'.'⍳⍨⌽⍵ ⋄ (d↓⍵)(t↑⍵)}   ⍝ '#.ns' 'name' ← SplitNs '#.ns.name'  - ⍵ must be fully qualified - where will be empty for roots
    IsParent←{p←⍵.## ⋄ ⍺∊p ⍵:1 ⋄ ⍵=p:0 ⋄ ⍺∇p }  ⍝ is ⍺ parent of ⍵

    Execute←{⍺←⎕DMX.⎕NS⍬ ⋄ ⍺⍎⍵}             ⍝ safe execute (avoid clash with our stuff) ⋄ missing ⍺ requires fully qualified name
    _IsRootName←∊∘('#') (,'#') ('⎕SE')('⎕DMX')
    _IsNameChar←∊∘'#.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyzÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝßàáâãäåæçèéêëìíîïðñòóôõöøùúûüþⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ∆⍙'
    ∇ ok←_IsAplName name;mask
    ⍝ avoid executing any string when trying to reference a namespace with ⍎
      :If ~ok←∧/mask←_IsNameChar name
          ⍝ allow ⎕SE and ⎕DMX in it
          ok←∧/mask←mask∨('⎕SE.'⍷name)∨('⎕DMX.'⍷name)
      :EndIf
    ∇
    IsRootName←{⍺←⊢ ⋄ _IsRootName ⊂⍵:1 ⋄ ~_IsAplName ⍵:0 ⋄ 0::0 ⋄ IsRoot ⍺ Execute ⍵}    ⍝ is name of a root
    ∇ nc←{nsref}NameClass name
    ⍝ safe name class (avoid clash with our stuff)
    ⍝ return ¯9 for trad ns
      :If 900⌶⍬ ⋄ nsref←⎕DMX.⎕NS ⍬ ⋄ :EndIf
      :If 9.1=nc←nsref.⎕NC⊂,name
      :AndIf ~IsScripted nsref⍎name
          nc←¯9
      :ElseIf ¯1=nc  ⍝ root reports ¯1
      :AndIf nsref IsRootName name
          nc←¯9
      :EndIf
    ∇

    ∇ (container ns)←rsi_xsi ContainerNs ns;n;rsi;xsi
    ⍝ container is a reference, and namespace is fully qualified namespace name
      (rsi xsi)←rsi_xsi
      :If 9=⎕NC'ns'
          (container ns)←#(⍕ns)
      :Else
          n←xsi{(⍵∊⍺)×¯1+⍺⍳⍵}⊂'⎕SE.UCMD' ⍝ Drop UCMD stack if present
          container←⊃n↓rsi
          ns←(⍕container),(0≠≢ns)/'.',ns
      :EndIf
    ∇

    ∇ r←{where}(create GetRefTo)ns;name;nc;parent
    ⍝ Get a reference to a container namespace (or ⍬ if that is not possible)
      :If 9=⎕NC'ns' ⋄ r←ns ⋄ :Return ⋄ :EndIf ⍝ already a ref
      r←⍬ ⋄ :If 900⌶⍬ ⋄ where←⎕DMX.⎕NS ⍬ ⋄ :EndIf
      :If 9=⌊|nc←where NameClass ns      ⍝ is a fully qualified name
          r←⍎ns
      :ElseIf 0≠nc ⍝ Invalid or used name, not worth trying
      :ElseIf create  ⍝ doesn't exist yet - attempt to create it
          :Trap 0 ⋄ r←⍎ns where.⎕NS''  ⍝ create it
          :Else ⋄ r←⍬    ⍝ can't be created
          :EndTrap
      :EndIf
    ∇

    NormNs←{⍺←⊢ ⋄ ⍕⍺(0 GetRefTo)⍵}    ⍝ normalise a namespace name - can swallow a ref too

    :EndSection





    :Section Lookup

    ∇ ok←HasLinks
      :If ok←×⎕NC'⎕SE.Link.Links'
      :AndIf ok←×≢⎕SE.Link.Links
          ⎕SE.Link.Links/⍨←0≠⎕NC ⎕SE.Link.Links.ns
          ok←×≢⎕SE.Link.Links
      :EndIf
    ∇
    ∇ linkns←LookupFile file;dirs;inx;mask
    ⍝ look up which linked directory has file
      :If HasLinks
          dirs←⎕SE.Link.Links.dir
      :AndIf ∨/mask←dirs Begins¨⊂file
          inx←⊃⍒mask×≢¨dirs ⍝ longest directory containing file
          linkns←inx⊃⎕SE.Link.Links
      :Else
          linkns←⍬
      :EndIf
    ∇
    ∇ linkns←LookupRef nsref;linked;nss
    ⍝ lookup which linked namespace has nsref
      linkns←⍬
      :If 0≠⎕NC'⎕SE.Link.Links'
      :AndIf 0≠≢⎕SE.Link.Links
          nss←⍎¨⎕SE.Link.Links.ns
          :While ~linked←nsref∊nss
          :AndIf ~IsRoot nsref
              nsref←nsref.##
          :EndWhile
          :If linked
              linkns←(nss⍳nsref)⊃⎕SE.Link.Links
          :EndIf
      :EndIf
    ∇
    ∇ {opts}←{defopts}DefaultOpts opts;Default;nl
    ⍝ Get default modifiers for link options namespace
      :If ''≡0⍴opts ⋄ opts←##.Array.Deserialise opts ⍝ pseudo array notation (experimental)
      :Else ⋄ opts←⎕NS opts  ⍝ duplicate namespace to avoid changing caller's
      :EndIf
      Default←opts.{(⊆⍺){0=⎕NC ⍺:⍎⍺,'←⍵'}¨⊆⍵}
      'source'Default'dir'
      'watch'Default(1+CanWatch)⊃'ns' 'both'
      'flatten' 'caseCode' 'forceExtensions' 'forceFilenames' 'fastLoad'Default 0
      'beforeWrite' 'beforeRead' 'getFilename' 'customExtensions'Default''
      'codeExtensions'Default⊂'aplf' 'aplo' 'apln' 'aplc' 'apli' 'dyalog' 'apl' 'mipage'
      opts.codeExtensions{⍵↓¨⍨⍺=⊃¨⊆⍵}∘⊆⍨←'.'
      'typeExtensions'Default 0 2⍴0 ''
      opts.typeExtensions{_←⍺⍪⍵ ⋄ _[∪⍳⍨⊣/_;]}←↑(2 'apla')(3 'aplf')(4 'aplo')(9.1 'apln')(9.4 'aplc')(9.5 'apli')
      :If ~900⌶⍬ ⋄ :AndIf ~0∊⍴nl←defopts.⎕NL ¯2 ⍝ some more custom defaults
          nl Default¨defopts⍎¨nl
      :EndIf
    ∇

    :EndSection




    :Section Link Private function    ⍝ to avoid clobber auto-complete in ⎕SE.Link

    ∇ src←GetRefSource ns
      :Trap 16 ⋄ src←⎕SRC ns
      :Else ⋄ src←⎕NULL  ⍝ traditional namespace
      :EndTrap
    ∇
    ∇ src←{ns}GetAplSource name;nc
    ⍝ src is a vector of text vectors, unless traditional namespace with get ⎕NULL
    ⍝ name may be empty to get the source of ns
      :If 0∊⍴name
          src←GetRefSource ns
      :Else
          :If 900⌶⍬ ⋄ ns←⎕NS ⍬ ⋄ :EndIf
          nc←ns.⎕NC⊂,name
          :Select nc
          :Case 2.1 ⍝ variable
              :Trap 11 ⋄ src←##.Array.Serialise ns⍎name
              :Else ⋄ Error'Unsupported array: ',(⍕ns),'.',name
              :EndTrap
          :CaseList 3.1 3.2 4.1 4.2 ⋄ src←ns.⎕NR name ⍝ tradfn/dfn/tradop/dop
          :CaseList 9.1 9.4 9.5 ⋄ src←GetRefSource ns⍎name ⍝ ns/class/interface
          :Else ⋄ Error('Cannot get source of ',(⍕ns),'.',name,': invalid name class (',(⍕nc),')')
          :EndSelect
      :EndIf
    ∇
    ∇ src←GetFileSource file;type
      src←⍬
      :Trap 0
          :If 1=type←1 ⎕NINFO file ⋄ src←⎕NULL  ⍝ directory → namespace
          :ElseIf 2=type ⋄ src←⊃⎕NGET file 1    ⍝ file
          :EndIf
      :EndTrap
    ∇

    ∇ (name nc)←{where}Fix(name src);file;invalid;names;nc;unnamed
    ⍝ Fix source and return names and nameclass
    ⍝ src may be actual source (⎕NULL or vector of strings) or file name (string)
    ⍝ nameclass is 0 if no valid source was found, ¯1 if name is invalid, ¯9 if trad namespace
      :If 900⌶⍬ ⋄ where←⎕DMX.(⎕NS ⍬) ⋄ :EndIf  ⍝ fix in dummy namespace that cannot break anything (e.g. ':Namespace' '##.⎕IO←0' ':EndNamespace')
      :If 1=≡src ⋄ src←'file://',file←src ⋄ :Else ⋄ file←'' ⋄ :EndIf  ⍝ file name given instead of source
      ⍝ attempt to fix as named script because this is the most commly expected format
      :Trap 11
          ⍝ actual apl name may be different from what was expected
          names←2 where.⎕FIX src  ⍝ fn/op/script - can work from file
          :If 1=≢names ⋄ name←⊃names ⋄ nc←where.⎕NC⊂name
          :Else ⋄ name←'' ⋄ nc←0  ⍝ multiple names in single file not supported
          :EndIf
          :Return  ⍝ named script fixed
      :Else
          unnamed←121=⎕DMX.ENX  ⍝ 2 ⎕FIX failed because script was unnamed
      :EndTrap
      ⍝ name must be valid because we define it in the following code
      :If ¯1=⎕NC,name ⋄ :AndIf ~IsRootName name ⋄ nc←¯1 ⋄ :Return ⋄ :EndIf
      :If unnamed  ⍝ unnamed script
          name where.{⍎⍺,'←⎕FIX ⍵'}src  ⍝ can work from file
          nc←where.⎕NC⊂,name
          :Return  ⍝ unnamed script fixed
      :EndIf
      ⍝ remaining possibilities are array or trad ns
      :If ~0∊⍴file  ⍝ they both require source, not filename
          src←GetFileSource file
      :EndIf
      :If src≡⎕NULL  ⍝ trad namespace - was not tested before because the 1=1⎕NINFO would have been costy
          name where.⎕NS'' ⋄ nc←¯9
          :Return  ⍝ trad ns created
      :EndIf
      :Trap 0
          name where.{⍎⍺,'←⍵'}##.Array.Deserialise src  ⍝ array
          nc←where.⎕NC⊂,name
      :Else
          name←'' ⋄ nc←0  ⍝ unknown
      :EndTrap
    ∇
    ∇ ok←target QFix(file name tie);nc;src
      :If tie ⋄ src←file ⍝ tie to file
      :Else ⋄ src←GetFileSource file  ⍝ pure source - no tied
      :EndIf
      (name nc)←target Fix(name src)
      ok←~nc∊0 ¯1
    ∇
    ∇ (file oldfile nc)←opts(depth DetermineFileName)(where name oldname src);cache
    ⍝ opts cached for performance on ns lookup
      cache←opts,opts.(dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)
      :If depth ⋄ (file oldfile nc)←↓⍉↑cache∘DetermineFileNameSub¨↓⍉↑(where name oldname src)
      :Else ⋄ (file oldfile nc)←cache DetermineFileNameSub(where name oldname src)
      :EndIf
    ∇
    ∇ (file oldfile nc)←opts DetermineFileNameSub(where name oldname src);beforeWrite;caseCode;dir;ext;fastLoad;flatten;forceExtensions;forceFilenames;getFilename;isroot;nc;ns;oldfile;path;ref;subdir;typeExtensions;userfile
    ⍝ what should the file name be according to link
    ⍝ src may be the (nested) text source of item, or may be the scalar name class
    ⍝ where must have been through U.NormNs
      ⍝ values cached for performance on ns lookup
      (opts dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)←opts
      :If 0=⎕NC where ⋄ oldfile←'' ⋄ ref←⎕NULL   ⍝ namespace doesn't exist - src or nc ought to be provided
      :Else ⋄ ref←⍎where ⋄ oldfile←ref CurrentFileName name         ⍝ Grab file info before ⎕FIX might destroy it
      :EndIf
      file←(oldname≡name)/oldfile  ⍝ if object was renamed we don't have a file name any more
      :If (0∊⍴src)∨(src≡0)  ⍝ no information about item - item must exist
          nc←ref NameClass name  ⍝ no source : item must exist
          :If 0=nc ⋄ Log'Source of name ',where,'.',name,' doesn''t exist' ⋄ :EndIf
      :ElseIf 0=≡src ⋄ nc←src ⍝ (non-zero) name class is given
      ⍝:ElseIf opts.fastLoad ⋄ nc←0  ⍝ nope - fastLoad is used only by FixFiles which then shouldn't call DetermineFileName
      :Else   ⍝ infer name class from (non-empty) source
          (name nc)←Fix name src  ⍝ fix in dummy namespace
      :EndIf
      :If nc=¯1 ⋄ file←'' ⋄ :Return ⋄ :EndIf  ⍝ invalid
      ⍝ trad namespace are given name class ¯9
      :If isroot←nc=¯9 ⋄ isroot←ns≡where,'.',name ⋄ :EndIf ⍝ we're asking for the root of the link
      :If 0=≢file                   ⍝ no existing file name for it
      :OrIf forceFilenames     ⍝ force using the default
          :If isroot  ⍝ if we're asking for opts.ns then the answer is opts.dir
              file←dir
          :Else
              :If ~flatten                ⍝ flatten prevents subdirectory hierarchy
                  file←(≢ns)↓where              ⍝ Add sub.namespace structure
                  ((file='.')/file)←'/'            ⍝ Convert dots to /
              :EndIf
              file←dir,file               ⍝ Add link directory
              file,←'/',name                  ⍝ Add object name
          :EndIf
          file,←typeExtensions Tail nc               ⍝ Add extension
      :EndIf
      file←(dir CaseCode flatten)⍣caseCode⊢file ⍝ case coded-name (if required)
      :If ¯9=nc ⋄ file←0 NormDir file ⋄ :EndIf  ⍝ for ⎕NPARTS to work on it
      (subdir file ext)←⎕NPARTS path←file
      :If forceExtensions∨0=≢ext
      ⍝:OrIf ~⎕NEXISTS path    ⍝ why ??? file is not supposed to exist yet
          ext←typeExtensions Tail nc
      :EndIf
      :If isroot<forceFilenames ⋄ file←CaseCodePart⍣caseCode⊢name ⋄ :EndIf  ⍝ forceFileNames does not affect directory - only leaf name
      file←subdir,file,ext
      file←ApplyOldExtn⍣(~forceExtensions)⊢file  ⍝ doesn't sound like a good idea - the existing .dyalog file could define something different (in particular if one of the two files is an array and casecode is off)
      ⍝ Allow user to determine file name - they return '' to give up
      :If 3=(⍎ns).⎕NC getFilename
      :AndIf 0<≢userfile←(ns⍎getFilename)'getFilename'opts file(ns,'.',name)nc(ns,'.',oldname)
          file←userfile
      :EndIf
    ∇
    ∇ expname←expname(forcefile MergeFileName forceext)actname;actdir;actext;actfile;expdir;expext;expfile
    ⍝ enforce forceFilenames/forceExtensions on actual file name, based on expected file name
      :If (forcefile∨forceext)∧(actname≢expname)
          :If Slash⊃⌽actname  ⍝ directory - ⎕NPARTS won't work
              expname←(1+forcefile)⊃actname expname
          :Else
              ((expdir expfile expext)(actdir actfile actext))←⎕NPARTS¨expname actname
              expname←actdir,((1+forcefile)⊃actfile expfile),((1+forceext)⊃actext expext)
          :EndIf
      :EndIf
    ∇

    ∇ (ns name nc)←CurrentAplName file;fullname;info;row
      :If 0≠≢info←↑GetFileInfo file  ⍝ file actually linked by interpreter
      :AndIf (≢info)≥row←info[;5 6]⍳0 0  ⍝ file defines a single object
          ns←NormNs⍕⊃info[row;2] ⋄ name←⍕⊃info[row;1]  ⍝ NormNs due to 5174⌶ sometimes reporting full path in first column
          nc←# NameClass ns,'.',name  ⍝ no need to protect fully-qualified name
      :Else
          ns←name←'' ⋄ nc←¯1
      :EndIf
    ∇
    ∇ (where expname actname nc)←opts DetermineAplName files;cache
    ⍝ opts cached for performance on ns lookup
      cache←opts,opts.(dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)
      (where expname actname nc)←⊃⍣(1=≡,files)⊢↓⍉↑cache∘DetermineAplNameSub¨⊆files
    ∇
    ∇ (where expname actname nc)←opts DetermineAplNameSub file;beforeWrite;caseCode;dir;fastLoad;flatten;forceExtensions;forceFilenames;fullname;getFilename;ns;src;subdir;typeExtensions
    ⍝ ns is the target namespace
    ⍝ expname is apl name expected from file name
    ⍝ actname is actual list of names fixed from file
    ⍝ nc is name class of name
    ⍝ opts cached for performance on ns lookup
      (opts dir ns flatten caseCode typeExtensions forceFilenames forceExtensions beforeWrite getFilename fastLoad)←opts
      :If fastLoad ⋄ src←''     ⍝ do not spend time inspecting source
      :Else ⋄ src←GetFileSource file
      :EndIf
      file←dir StripCaseCode flatten⊢file  ⍝ always strip case code - apl name can't have them anyways
      (subdir file)←2↑⎕NPARTS file  ⍝ drop extension
      :If 0=≢file ⋄ subdir←¯1↓subdir ⋄ :EndIf  ⍝ drop trailing slash for directories
      (where expname)←SplitNs fullname←ns,DotSlash(≢dir)↓subdir,file
      :If flatten ⋄ where←⍕ns ⋄ :EndIf     ⍝ all subdirectories link to linked namespace
      :If fastLoad ⋄ (actname nc)←expname 0  ⍝ settle with expname
      :ElseIf 0=≢src ⋄ (actname nc)←'' 0             ⍝ no source
      :Else ⋄ (actname nc)←Fix expname src           ⍝ inspect source
      :EndIf
      :If (0=≢where)∧(nc=¯9) ⋄ :AndIf IsRootName actname ⋄ where←actname  ⍝ file is linked dir and ns is a root - where≡expname≡actname≡ns
      :ElseIf ¯1=⎕NC where ⋄ :AndIf ~IsRootName where ⋄ nc←¯1  ⍝ invalid namespace path - avoid costy IsRootName if possible
      :EndIf
    ∇



    ∇ outFail←opts WriteFiles(ns dir);count;dir;files;i;inx;mask;names;nsref;ok;oldfiles;src;tradfiles;tradnames
    ⍝ Write items to file in folders
    ⍝ ns must be a fully specified traditional namespace
    ⍝ arrays not supported
      outFail←0⍴⊂'' ⋄ nsref←⍎ns
      ⍝ Create directory for namesapce
      3 ⎕MKDIR dir ⋄ outFail,←(~⎕NEXISTS dir)/⊂ns  ⍝ can't create directory
      ⍝ Write children to files (except trad namespaces)
      :If 0≠≢names←nsref.⎕NL-NameClasses 0
          src←nsref GetAplSource¨names
          mask←0=≢¨src     ⍝ can't get source
          outFail,←(ns,'.')∘,¨mask/names
          (names src)←(~mask)∘/¨(names src) ⋄ count←≢names
          (files oldfiles)←2↑opts(1 DetermineFileName)(count/⊂ns)names names(count/⊂'')  ⍝ names are known to exist so don't provide source
          :If ∨/mask←(inx←⍳⍨819⌶¨files)≠(⍳≢files) ⍝ TODO should really test the whole list of files after recursion, in case beforeWrite messed up the names
              ⍝ cannot let user do this on any platform - if the directory is moved to windows then the user will be screwed
              names←names[,(mask/inx),[1.5]⍸mask]
              Error'File name case clash - try using caseCode←1:',⍕(ns,'.')∘,¨names
          :EndIf
          mask←src∊⎕NULL  ⍝ traditional namespaces
          (tradnames tradfiles)←mask∘/¨(names files)
          (files oldfiles names src)/⍨←⊂(~mask)
          :If 0≠≢files
              :If 3=opts.(⎕NC beforeWrite)  ⍝ user callback on file write - not on directories
                  mask←(≢files)⍴1
                  :For i :In ⍳⍴files
                      mask[i]←(⍎opts.beforeWrite)'beforeWrite'opts(i⊃files)(ns,'.',i⊃names)(nsref NameClass i⊃names)(ns,'.',i⊃names)src
                  :EndFor
                  (files oldfiles names src)/⍨←⊂mask  ⍝ keep what was not processed by user
              :EndIf
              mask←src Into¨files  ⍝ failed to write
              outFail,←(ns,'.')∘,¨(~mask)/names
              :If ∨/mask←mask∧(oldfiles≢¨files)∧(0≠≢¨oldfiles)  ⍝ delete oldfilename which was incorrect if write was successful
                  ⎕NDELETE¨mask/oldfiles
              :EndIf
          :EndIf
          :If 0≠≢tradfiles ⍝ recurse on traditional namespaces
              tradnames←(ns,'.')∘,¨tradnames
              outFail,←⊃,/opts∘WriteFiles¨↓tradnames,[1.5]tradfiles
          :EndIf
      :EndIf
    ∇

    ∇ {inFail}←opts FixFiles(target source);FixFile;actnames;actnc;allfiles;allnames;dirs;expfiles;expnames;exts;files;hidden;i;inx;list;mask;names;ndirs;nss;parents;quadfiles;source;tie
    ⍝ Load items from files in folders
      inFail←⍬
      list←↑0 1 6 ⎕NINFO⍠1⍠'Recurse' 1⊢source,'/*'    ⍝ recursive listing of everything  list[filename type hidden;]
     
      mask←1=list[3;] ⋄ list←¯1↓list                  ⍝ mask for hidden items
      hidden←mask/list ⋄ list/⍨←~mask                 ⍝ crop hidden (files and) folders
      hidden←(1=hidden[2;])/hidden[1;]                ⍝ keep directories only (files have already been removed from list)
      hidden←hidden,¨'/'                              ⍝ protect against similarly named files
      list/⍨←~∨⌿hidden∘.Begins list[1;]             ⍝ filter away things that come below hidden directories
     
      dirs←(1=list[2;])/list[1;]                      ⍝ second column has 1 for dirs
      dirs←((⊂opts.dir),{⍵[⍋⍵]}dirs),¨'/'             ⍝ all directories (including link root)
     
      files←(2=list[2;])/list[1;]                     ⍝ second column has 2 for files; first column is filename
      files/⍨←opts HasExtn files                    ⍝ must be of correct extension
      files←files[GradeFiles files]                 ⍝ dirs then quads then files
      :If 0∊⍴files ⋄ :Return ⋄ :EndIf
     
      ndirs←≢dirs ⋄ allfiles←dirs,files
     
      (parents expnames actnames actnc)←opts DetermineAplName allfiles  ⍝ expected names (one per file), actual names (one list per file), actual name classes (one list per file)
      :If opts.fastLoad  ⍝ do not spend time avoiding name clashes - actnc will be all 0's anyway
          allnames←parents('.'JoinEach)expnames  ⍝ do not infer true apl name from source
      :Else
          mask←actnc∊¯1 0    ⍝ invalid names or source
          inFail,←mask/allfiles
          (allfiles parents expnames actnames actnc)/⍨←⊂~mask    ⍝ keep only names that are valid
          ndirs←+/ndirs↑~mask
          allnames←parents('.'JoinEach)actnames  ⍝ fully qualified names
          :If ∨/mask←(inx←⍳⍨allnames)≠(⍳≢allnames)
              files←allfiles[,(mask/inx),[1.5]⍸mask]
              Error'Files produce clashing APL names:',⍕files
          :EndIf
      :EndIf
     
      ⍝ rename files if incorrectly named - cannot work with opts.fastLoad
      :If (0<≢allfiles)∧opts.(fastLoad<forceExtensions∨forceFilenames)
          expfiles←⊃opts(1 DetermineFileName)parents actnames actnames actnc
          expfiles←expfiles(opts.forceFilenames MergeFileName opts.forceExtensions)¨allfiles
          :If ∨/mask←expfiles≢¨allfiles
              :If (≢expfiles)≠(≢∪819⌶expfiles)
                  Error'Forcing file names would produce clashing file names: use forceFilenames=0 or caseCode=1'
              :Else
                  ⍝ because APL names don't clash, we now expfiles won't clash either
                  ⍝ however expfiles may overlap allfiles, producing an error at intermediate steps (⎕NMOVE should fail, because ⍠'IfExists' 'Error')
                  (mask/expfiles)Relocate(mask/allfiles)
                  allfiles←expfiles
              :EndIf
          :EndIf
      :EndIf
     
      :If 3=⎕NC opts.beforeRead ⍝ user handler defined?
          mask←(⍴allfiles)⍴1
          :For i :In ⍳⍴allfiles
              mask[i]←(opts⍎opts.beforeRead)'beforeRead'opts(i⊃allfiles)(i⊃allnames)(i⊃actnc) ⍝ return 1 to continue else 0
          :EndFor
          (allfiles parents expnames actnames actnc)/⍨←⊂mask    ⍝ keep what was not processed by user
      :EndIf
     
      tie←'both' 'ns'∊⍨⊂opts.watch ⍝ tie to file if watching namespace - cached for performance
      FixFile←tie∘{(target file name)←⍵ ⋄ target QFix file name ⍺}
      ⍝ create namespaces for directories and load quadVars.apln
      (dirs names)←ndirs↑¨(allfiles allnames)
      :If ~0∊⍴dirs
          :If ~opts.flatten                               ⍝ If we are not flattening, create nss
              nss←names ⎕NS¨⊂⍬
              :If ∨/mask←0=≢¨nss   ⍝ could not create namespace
                  inFail,←mask/names
              :EndIf
          :Else
              nss←target   ⍝ all files fixed in target namespace
          :EndIf
          ⍝ set sysvars before anything else - these files are produced by Acre and must be supported
          :If ∨/mask←⎕NEXISTS¨quadfiles←dirs,¨⊂'quadVars.apln'
              mask←mask\~FixFile¨↓nss,mask⌿quadfiles,[1.5]⊂'quadVars'
              inFail,←mask/quadfiles
          :EndIf
      :Else ⋄ quadfiles←0⍴⊂''
      :EndIf
     
      ⍝ fix individual files
      (files names)←ndirs∘↓¨(allfiles allnames)
      (files names)/⍨←⊂~files∊quadfiles
      :If ~0∊⍴files
          :If ~opts.flatten                               ⍝ If we are not flattening, create nss
              nss←⍎∘Parent¨names
          :Else
              nss←target   ⍝ all files fixed in target namespace
          :EndIf
          mask←~FixFile¨↓nss,files,[1.5]names ⍝ try it and return only failures
          inFail,←mask/files
      :EndIf
     
      ⍝ return list of failures
      inFail←⍕¨inFail
    ∇

    :EndSection





    :Section UI

    ∇ {msg}←{header}Warn msg
    ⍝ Warn user
      :If 900⌶⍬ ⋄ header←']Link Warning: ' ⋄ :EndIf
      ⎕←msg←↑header∘,¨@1⊢,⊆,msg
    ∇

    ∇ {msg}←Log msg
    ⍝ Debug information
      :If debug≠0
          ⎕←msg
      :EndIf
    ∇
    ∇ r←ViewMetaData mode
    ⍝ Experiemental function to inspect Link meta data.
    ⍝ For debugging only.
    ⍝ !!! DO NOT USE THIS function in application code!!!
      r←5177⌶⍬
      r←(~(8↑¨⍕¨2⊃¨r)∊⊂'⎕SE.Link')/r
      r←r[⍋⍕⌽↑2↑¨r]
     
      :Select mode
      :Case 'raw' ⋄ →0
      :Case 'count' ⋄ r←(⍕¨2⊃¨r){⍺(≢⍵)}⌸1⊃¨r
      :Case 'group' ⋄ r←(⍕¨2⊃¨r){⍺ ⍵}⌸1⊃¨r
      :CaseList '' 'report'
          r←↑4↑¨r
          r[;1]←(⍕¨r[;2]),¨'.',¨r[;1]
          r←r[;1 3 4]
      :Else
          'mode must be one of: raw count group report'⎕SIGNAL 11
      :EndSelect
    ∇

    :EndSection

:EndNamespace
