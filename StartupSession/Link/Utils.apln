:Namespace U ⍝ Utilities

    :Section Constants
    isWindows←'Win'≡3↑⊃# ⎕WG'APLVersion'
    ∇ (canwatch dotnetcore)←_CanWatch;⎕USING
      :Trap 0
        ⍝ Try .Net Core rather than Framework if non-Windows or DYALOG_NETCORE explicitly set
          dotnetcore←(~isWindows)∨(,'1')≡2 ⎕NQ'.' 'GetEnvironment' 'DYALOG_NETCORE'
          ⎕USING←',System',(~dotnetcore)/'.dll'
          canwatch←9.6=⎕NC⊂'System.IO.FileSystemWatcher'
      :Else
          canwatch←dotnetcore←0
      :EndTrap
    ∇
    (CanWatch DotNetCore)←_CanWatch ⍝ cache result
    ∇ d←debug
      :If 0=⎕NC'##.DEBUG'
          d←##.DEBUG←0
      :Else
          d←##.DEBUG
      :EndIf
    ∇
    :EndSection


    :Section APL covers
      OnEach←{ ⍝ ¨ without prototype call on empty
          0∊⍴⍵:⍵   ⍝ if empty return empty
          ⍺←⊢      ⍝ ambivalent
          1:_←⍺ ⍺⍺¨⍵   ⍝ shy call
      }
    :EndSection


    :Section Stack Frames      ⍝ Tacit necessary to avoid them
    Resignal←⎕SIGNAL{⍺←'' ⋄ ⍵/⊂⎕DMX.(('EN'(EN+11×EN=0))('Message'(Message,⍺)))}
        Check←{⍺←0⋄⍺}⍴⍨¯1∊∘⎕NC⊢⊆⍨'/'≠⊢ ⍝ leave early if any bad name
    If←⍴⍨
    ERRNO←99              ⍝ official API error number
    Error←⎕SIGNAL∘ERRNO
    :EndSection



    :Section Strings
    Shortest←{⍵⊃⍨{⍵⍳⌊/⍵}≢¨⍵}                ⍝ Shortest string in list
    Case←{⍺(819⌶)¨⍵}                        ⍝ Upper/Lower case
    LCase←{819⌶⍵}                           ⍝ Lower case
    Join←{(⍕⍺),⍺⍺,(⍕⍵)}                     ⍝ Join using ⍺⍺
    Slash←{⍵∊'/\'}                          ⍝ Mark slashes
    Parts←{⍵⊆⍨~Slash ⍵}                     ⍝ Path parts
    TilLast←{⍵↓⍨-⍺⍳⍨⌽⍵}
    Path←'/'∘TilLast                        ⍝ Until last slash
    Parent←'.'∘TilLast                      ⍝ Until last dot
    PadThis←{⍵,'⎕THIS'/⍨0=≢⍵}               ⍝ Default path to here
    NsExpr←{'''',⍵,'''⎕NS⍬'}                ⍝ Expression to create namespace
    Begins←{⊃⍺⍷⍵}                           ⍝ ⍵ starts with ⍺
    WinSlash←'\'@Slash⍣isWindows            ⍝ force windows slashes only on windows machines
    DotSlash←'.'@Slash                      ⍝ Convert dots to slashes
        Combine←{(⍕⍺),⍨(326≠⎕DR ⍺)/'.',⍨⍕⍵}/
    List←{∊{' ',⍕⍵}¨⍵}
      Arrow←{                               ⍝ appropriate symbol to show ns-dir connection
          lr←'←→'/⍨2 2⊤'ns' 'dir' 'both'⍳⊂⍵.watch
          ⍵.ns,' ',lr,' ',WinSlash ⍵.dir
      }

    :EndSection


    :Section Covers for I-beams and other built-ins
    CurrentFileName←{4⊃⍺.(5179⌶)⍵}   ⍝ Return current file name attached to apl name ⍵ in namespace ⍺
    Where←{⍵⌿⍺}                      ⍝ Filter as function
    GetFileInfo←{5174⌶⍵}             ⍝ Return links to file
      GetFile←{
          11::⊃⎕NGET ⍵ 1                     ⍝ 17.0 Unicode
          ⊃⎕NGET⍠'ContentType' 'APLCode'⊢⍵ 1 ⍝ 17.1+ Classic
      }
      GetInfos←{
          ''≡0⍴⍵:∇'name' 'parent' 'nc' 'file' 'line' 'lines' 'hash' 'ts'⍳⊂⍵
          ⍵∘⊃¨5177⌶⍬
      }

    ∇ r←RemoveFileLinksIn rootns;all;allrefs;urefs;mask;t;remove
     ⍝ Find all file system links to objects below rootns, and remove using 5178⌶
     ⍝ Return number of links broken
      allrefs←2⊃¨all←5177⌶⍬
      t←urefs←∪allrefs
      mask←(≢urefs)⍴0
      :If 0≠≢t
          :Repeat
              mask∨←t∊rootns ⍝ Have we reached rootns?
              t←t.##         ⍝ Move all pointers up to parent
          :Until t≡t.##      ⍝ Continue until everything is "root"
      :EndIf
      :If 0≠r←≢remove←(allrefs∊mask/urefs)/all ⍝ links to be removed
          r←+/5178⌶¨(⍕¨2⊃¨remove),¨'.',¨⍕¨1⊃¨remove
      :EndIf
    ∇
    :EndSection



    :Section Files

    NormFile←{∊1⎕NPARTS ⍵}
    ∇ dir←trail NormDir dir
      dir←∊1 ⎕NPARTS dir                 ⍝ normalise - '' means current dir
      :If trail ⋄ dir,←'/'/⍨~'/\'∊⍨⊃⌽dir ⍝ append trailing slash if missing
      :Else ⋄ dir↓⍨←-+/∧\⌽dir∊'/\'       ⍝ remove trailing slash
      :EndIf
      ⍝ dir←WinSlash dir                   ⍝ use windows slash on windows machines
    ∇

    Ancestry←{((¯1+⍵⍳'/')↑⍵)∘,¨,\('/'=⍵)⊂⍵}

    FileHash←{2 ⎕NQ #'GetBuildID' ⍵}

      IsDir←{
          22::0
          1=1 ⎕NINFO ⍵
      }

      Into←{ ⍝ Put vtv ⍺ into file ⍵ - return success
          22::0                  ⍝ no file access
          _←3 ⎕MKDIR⊃1 ⎕NPARTS ⍵ ⍝ create dir if needed
          1⊣(⊂⍺)⎕NPUT ⍵ 1        ⍝ overwrite
      }

      ApplyOldExtn←{ ⍝ Correct new extension to .dyalog if old source exists
          (dir name ext)←⎕NPARTS ⍵
          ext≡'.dyalog':⍵
          alt←dir,name,'.dyalog'
          (⎕NEXISTS alt)>(⎕NEXISTS ⍵):alt
          ⍵
      }

    ∇ name←CaseCode name;bin;digits;len;⎕IO
      ⎕IO←0
      →0 If 0=≢name  ⍝ empty name doesn't get case coded
      bin←name≠819⌶name
      len←⌈3÷⍨≢bin
      digits←2⊥⌽⍉⌽len 3⍴bin↑⍨3×len
      digits↓⍨←+/∧\0=digits
      name,←'-',⎕D[digits,0/⍨⍬≡digits]
    ∇
    ∇ name←StripCaseCode name;code;length;mask;⎕IO
      ⎕IO←0
      length←(⌽name)⍳'-'
      →0 If length∊0,≢name   ⍝ case code must be after hyphen
      code←⎕D⍳(-length)↑name
      name←((-length+1)↓name)
      →0 If code∨.>7         ⍝ case code must be octal digits
      mask←⌽,⍉2 2 2⊤code     ⍝ boolean mask of upper-case
      →0 If~(⊂(≢name)↓mask)∊⍬(,0)(0 0)  ⍝ mask must be padded with 0-2 zeros
      name←((≢name)↑mask)Case name
    ∇

    :EndSection


    :Section Namespaces

    IsScripted←{16::0 ⋄ 1⊣⎕SRC ⍵}           ⍝ is namespace scripted
    IsRoot←{⍵=⍵.##}                         ⍝ is namespace a root
    SplitNs←{t←1+d←-'.'⍳⍨⌽⍵ ⋄ (d↓⍵)(t↑⍵)}   ⍝ '#.ns' 'name' ← SplitNs '#.ns.name'
    SplitNsRef←{⍺⍎@1⊢SplitNs ⍵}             ⍝ #.ns 'name' ← # SplitNsRef 'ns.name'
    NormNs←{⍺←⎕NS⍬ ⋄ ⍕⍺⍎⍵}                  ⍝ normalise a namespace name

    NameClass←{⍺←⎕NS ⍬ ⋄ ⍺.⎕NC,⊂,⍵}         ⍝ safe name class (avoid clash with our stuff) ⋄ missing ⍺ requires fully qualified name
    Execute←{⍺←⎕NS⍬ ⋄ ⍺⍎⍵}                  ⍝ safe execute (avoid clash with our stuff) ⋄ missing ⍺ requires fully qualified name
    IsRootName←{0::0 ⋄ IsRoot Execute ⍵}    ⍝ is name of a root

    ∇ (container ns)←rsi_xsi ContainerNs ns;n;rsi;xsi
    ⍝ container is a reference, and namespace is fully qualified namespace name
      (rsi xsi)←rsi_xsi
      :If 9=⎕NC'ns'
          (container ns)←#(⍕ns)
      :Else
          n←xsi{(⍵∊⍺)×¯1+⍺⍳⍵}⊂'⎕SE.UCMD' ⍝ Drop UCMD stack if present
          container←⊃n↓rsi
          ns←(⍕container),(0≠≢ns)/'.',ns
      :EndIf
    ∇

    ∇ r←GetRefTo nsname;name;nc;parent
    ⍝ Get a reference to a container namespace (or ⍬ if that is not possible)
      :If 9=⌊nc←NameClass nsname      ⍝ already there
      :OrIf IsRootName nsname         ⍝ or a root
          r←⍎nsname
      :ElseIf 0≠nc ⍝ Invalid or used name, not worth trying
          r←⍬
      :Else  ⍝ doesn't exist yet - attempt to create it
          :Trap 0 ⋄ r←⍎nsname ⎕NS''  ⍝ create it
          :Else ⋄ r←⍬    ⍝ can't be created
          :EndTrap
      :EndIf
    ∇
    :EndSection



    :Section Lookup

      Tail←{ ⍝ ⍺:opts; ⍵:nc
          ¯9=⍵:'/'    ⍝ trad namespace are given name class ¯9
          (types exts)←↓⍉⍺.typeExtensions
          exts,←⊂'dyalog'
          exts,¨⍨←'.'
          exts⊃⍨⌊/types⍳⍵,⌊⍵
      }

    ∇ r←GetName file;code;ns
    ⍝ Attempt to determine the name which will be defined by a file
      ns←(⎕NS'').⎕NS r←'' ⍝ Two levels of nesting to allow safe fixing of :Namespace/##.⎕IO←0/:EndNamespace
      :Trap 0
          2 ns.⎕FIX'file://',file
          :If 1=≢r←ns.⎕NL-⍳10 ⋄ r←⊃r
          :Else ⋄ r←''
          :EndIf
      :EndTrap
    ∇

    ∇ linkns←LookupFile file;dirs;inx;mask
    ⍝ look up which linked directory has file
      :If 0≠≢⎕SE.Link.Links
          dirs←⎕SE.Link.Links.dir
      :AndIf ∨/mask←dirs U.Begins¨⊂file
          inx←⊃⍒mask×≢¨dirs ⍝ longest directory containing file
          linkns←inx⊃⎕SE.Link.Links
      :Else
          linkns←⍬
      :EndIf
    ∇


    :EndSection



    :Section Link Private function    ⍝ to avoid clobber auto-complete in ⎕SE.Link
    ∇ src←GetRefSource ns
      :Trap 16 ⋄ src←⎕SRC ns
      :Else ⋄ src←⎕NULL  ⍝ traditional namespace
      :EndTrap
    ∇
    ∇ src←{ns}GetSource name;nc
    ⍝ src is a vector of text vectors, unless traditional namespace with get ⎕NULL
    ⍝ name may be empty to get the source of ns
      :If 0∊⍴name
          src←GetRefSource ns
      :Else
          :If 900⌶⍬ ⋄ ns←⎕NS ⍬ ⋄ :EndIf
          nc←ns.⎕NC⊂,name
          :Select nc
          :Case 2.1 ⍝ variable
              :Trap 11 ⋄ src←,↓##.Serialise ns⍎name
              :Else ⋄ Error'Unsupported array: ',(⍕ns),'.',name
              :EndTrap
          :CaseList 3.1 3.2 4.1 4.2 ⋄ src←ns.⎕NR name ⍝ tradfn/dfn/tradop/dop
          :CaseList 9.1 9.4 9.5 ⋄ src←GetRefSource ns⍎name ⍝ ns/class/interface
          :Else ⋄ Error('Cannot get source of ',(⍕ns),'.',name,': invalid name class (',(⍕nc),')')
          :EndSelect
      :EndIf
    ∇

    ∇ {res}←{where}Fix(name src);names;nc
    ⍝ Fix source and return names and nameclasses
      :If 900⌶⍬ ⋄ where←⎕DMX.(⎕NS ⍬) ⋄ :EndIf  ⍝ fix in dummy namespace that cannot break anything (e.g. ':Namespace' '##.⎕IO←0' ':EndNamespace')
      :If src≡⎕NULL  ⍝ traditional namespace
          name where.⎕NS''
          names←,⊂,name ⋄ nc←,¯9
      :Else
          :Trap 0
              names←2 where.⎕FIX src  ⍝ fn/op/script - name may be different
              nc←where.⎕NC names
          :Else
              :If 121=⎕DMX.ENX  ⍝ unnamed - try again
                  name where.{⍎⍺,'←⎕FIX ⍵'}src
                  nc←where.⎕NC names←,⊂,name
              :Else   ⍝ expect array
                  :Trap 0
                      name where.{⍎⍺,'←⍵'}##.Deserialise src  ⍝ array
                      nc←where.⎕NC names←,⊂,name
                  :Else
                      names←0⍴⊂'' ⋄ nc←⍬  ⍝ unknown
                  :EndTrap
              :EndIf
          :EndTrap
      :EndIf
      res←(names nc)
    ∇
    ∇ (file oldfile)←DetermineFileName(opts ns name oldname src);dir;ext;isroot;names;nc;oldfile;path;userfile
    ⍝ what should the file name be according to link
    ⍝ fix=1 allows fixing source in target ns to determine name class ⋄ fix=0 forces the fix in a temporary namespace
      oldfile←ns CurrentFileName name         ⍝ Grab file info before ⎕FIX might destroy it
      file←(oldname≡name)/oldfile  ⍝ if object was renamed we don't have a file name any more
      :If 0=≢src ⋄ nc←ns.⎕NC⊂,name  ⍝ no source : item must exist
      :Else  ⍝ infer name class from source
          (names nc)←Fix name src  ⍝ fix in dummy namespace
          :If names≢,⊂name ⋄ Log'Source of name ',name,' produces names ',(⍕names) ⋄ :EndIf
          nc←⊃nc  ⍝ infer nameclass from source
      :EndIf
      :If isroot←nc=9.1 ⋄ :AndIf ~IsScripted ns
          isroot←(ns⍎name)≡(⍎opts.ns)  ⍝ we're asking for the root of the link
          nc←¯9   ⍝ trad namespace are given name class ¯9
      :EndIf
      :If 0=≢file                   ⍝ no existing file name for it
      :OrIf opts.forceFilenames     ⍝ force using the default
          :If isroot  ⍝ if we're asking for opts.ns then the answer is opts.dir
              file←opts.dir
          :Else
              :If ~opts.flatten                ⍝ flatten prevents subdirectory hierarchy
                  file←(≢opts.ns)↓⍕ns              ⍝ Add sub.namespace structure
                  ((file='.')/file)←'/'            ⍝ Convert dots to /
              :EndIf
              file←opts.dir,file               ⍝ Add link directory
              file,←'/',name                  ⍝ Add object name
          :EndIf
          file,←opts Tail nc               ⍝ Add extension
      :EndIf
      file←opts ##.CaseCode⍣opts.caseCode⊢file ⍝ case coded-name (if required)
      ⍝ Allow user to determine file name - they return '' to give up
      :If 3=(⍎opts.ns).⎕NC opts.beforeWrite
      :AndIf 0<≢userfile←(opts.ns⍎opts.beforeWrite)ns name oldname nc src file opts 1
          file←userfile
      :EndIf
      :If ¯9=nc ⋄ file←0 NormDir file ⋄ :EndIf  ⍝ for ⎕NPARTS to work on it
      (dir file ext)←⎕NPARTS path←file
      :If opts.forceExtensions∨0=≢ext
      ⍝:OrIf ~⎕NEXISTS path    ⍝ why ??? file is not supposed to exist yet
          ext←opts Tail nc
      :EndIf
      :If opts.forceFilenames ⋄ file←U.CaseCode⍣opts.caseCode⊢name ⋄ :EndIf  ⍝ forceFileNames does not affect directory
      file←dir,file,ext
      file←ApplyOldExtn⍣(~opts.forceExtensions)⊢file  ⍝ doesn't sound like a good idea - the existing .dyalog file could define something different (in particular if one of the two files is an array and casecode is off)
    ∇

    ∇ name←opts DetermineAplName file;dir
      file←opts ##.StripCaseCode file
      (dir file)←2↑⎕NPARTS file  ⍝ drop extension
      :If 0=≢file ⋄ dir←¯1↓dir ⋄ :EndIf  ⍝ drop trailing slash for directories
      name←opts.ns,DotSlash(≢opts.dir)↓dir,file
    ∇



    :EndSection

:EndNamespace
